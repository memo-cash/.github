
+++ b/trunk/base58.h
@@ -0,0 +1,201 @@
+// Copyright (c) 2009 Satoshi Nakamoto
+// Distributed under the MIT/X11 software license, see the accompanying
+// file license.txt or http://www.opensource.org/licenses/mit-license.php.
+
+
+//
+// Why base-58 instead of standard base-64 encoding?
+// - Don't want 0OIl characters that look the same in some fonts and
+//      could be used to create visually identical looking account numbers.
+// - A string with non-alphanumeric characters is not as easily accepted as an account number.
+// - E-mail usually won't line-break if there's no punctuation to break at.
+// - Doubleclicking selects the whole number as one word if it's all alphanumeric.
+//
+
+
+static const char* pszBase58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
+
+
+inline string EncodeBase58(const unsigned char* pbegin, const unsigned char* pend)
+{
+    CAutoBN_CTX pctx;
+    CBigNum bn58 = 58;
+    CBigNum bn0 = 0;
+
+    // Convert big endian data to little endian
+    // Extra zero at the end make sure bignum will interpret as a positive number
+    vector<unsigned char> vchTmp(pend-pbegin+1, 0);
+    reverse_copy(pbegin, pend, vchTmp.begin());
+
+    // Convert little endian data to bignum
+    CBigNum bn;
+    bn.setvch(vchTmp);
+
+    // Convert bignum to string
+    string str;
+    str.reserve((pend - pbegin) * 138 / 100 + 1);
+    CBigNum dv;
+    CBigNum rem;
+    while (bn > bn0)
+    {
+        if (!BN_div(&dv, &rem, &bn, &bn58, pctx))
+            throw bignum_error("EncodeBase58 : BN_div failed");
+        bn = dv;
+        unsigned int c = rem.getulong();
+        str += pszBase58[c];
+    }
+
+    // Leading zeroes encoded as base58 zeros
+    for (const unsigned char* p = pbegin; p < pend && *p == 0; p++)
+        str += pszBase58[0];
+
+    // Convert little endian string to big endian
+    reverse(str.begin(), str.end());
+    return str;
+}
+
+inline string EncodeBase58(const vector<unsigned char>& vch)
+{
+    return EncodeBase58(&vch[0], &vch[0] + vch.size());
+}
+
+inline bool DecodeBase58(const char* psz, vector<unsigned char>& vchRet)
+{
+    CAutoBN_CTX pctx;
+    vchRet.clear();
+    CBigNum bn58 = 58;
+    CBigNum bn = 0;
+    CBigNum bnChar;
+    while (isspace(*psz))
+        psz++;
+
+    // Convert big endian string to bignum
+    for (const char* p = psz; *p; p++)
+    {
+        const char* p1 = strchr(pszBase58, *p);
+        if (p1 == NULL)
+        {
+            while (isspace(*p))
+                p++;
+            if (*p != '\0')
+                return false;
+            break;
+        }
+        bnChar.setulong(p1 - pszBase58);
+        if (!BN_mul(&bn, &bn, &bn58, pctx))
+            throw bignum_error("DecodeBase58 : BN_mul failed");
+        bn += bnChar;
+    }
+
+    // Get bignum as little endian data
+    vector<unsigned char> vchTmp = bn.getvch();
+
+    // Trim off sign byte if present
+    if (vchTmp.size() >= 2 && vchTmp.end()[-1] == 0 && vchTmp.end()[-2] >= 0x80)
+        vchTmp.erase(vchTmp.end()-1);
+
+    // Restore leading zeros
+    int nLeadingZeros = 0;
+    for (const char* p = psz; *p == pszBase58[0]; p++)
+        nLeadingZeros++;
+    vchRet.assign(nLeadingZeros + vchTmp.size(), 0);
+
+    // Convert little endian data to big endian
+    reverse_copy(vchTmp.begin(), vchTmp.end(), vchRet.end() - vchTmp.size());
+    return true;
+}
+
+inline bool DecodeBase58(const string& str, vector<unsigned char>& vchRet)
+{
+    return DecodeBase58(str.c_str(), vchRet);
+}
+
+
+
+
+
+inline string EncodeBase58Check(const vector<unsigned char>& vchIn)
+{
+    // add 4-byte hash check to the end
+    vector<unsigned char> vch(vchIn);
+    uint256 hash = Hash(vch.begin(), vch.end());
+    vch.insert(vch.end(), (unsigned char*)&hash, (unsigned char*)&hash + 4);
+    return EncodeBase58(vch);
+}
+
+inline bool DecodeBase58Check(const char* psz, vector<unsigned char>& vchRet)
+{
+    if (!DecodeBase58(psz, vchRet))
+        return false;
+    if (vchRet.size() < 4)
+    {
+        vchRet.clear();
+        return false;
+    }
+    uint256 hash = Hash(vchRet.begin(), vchRet.end()-4);
+    if (memcmp(&hash, &vchRet.end()[-4], 4) != 0)
+    {
+        vchRet.clear();
+        return false;
+    }
+    vchRet.resize(vchRet.size()-4);
+    return true;
+}
+
+inline bool DecodeBase58Check(const string& str, vector<unsigned char>& vchRet)
+{
+    return DecodeBase58Check(str.c_str(), vchRet);
+}
+
+
+
+
+
+
+static const unsigned char ADDRESSVERSION = 0;
+
+inline string Hash160ToAddress(uint160 hash160)
+{
+    // add 1-byte version number to the front
+    vector<unsigned char> vch(1, ADDRESSVERSION);
+    vch.insert(vch.end(), UBEGIN(hash160), UEND(hash160));
+    return EncodeBase58Check(vch);
+}
+
+inline bool AddressToHash160(const char* psz, uint160& hash160Ret)
+{
+    vector<unsigned char> vch;
+    if (!DecodeBase58Check(psz, vch))
+        return false;
+    if (vch.empty())
+        return false;
+    unsigned char nVersion = vch[0];
+    if (vch.size() != sizeof(hash160Ret) + 1)
+        return false;
+    memcpy(&hash160Ret, &vch[1], sizeof(hash160Ret));
+    return (nVersion <= ADDRESSVERSION);
+}
+
+inline bool AddressToHash160(const string& str, uint160& hash160Ret)
+{
+    return AddressToHash160(str.c_str(), hash160Ret);
+}
+
+inline bool IsValidBitcoinAddress(const char* psz)
+{
+    uint160 hash160;
+    return AddressToHash160(psz, hash160);
+}
+
+inline bool IsValidBitcoinAddress(const string& str)
+{
+    return IsValidBitcoinAddress(str.c_str());
+}
+
+
+
+
+inline string PubKeyToAddress(const vector<unsigned char>& vchPubKey)
+{
+    return Hash160ToAddress(Hash160(vchPubKey));
+}
/trunk/bignum.h Diff Switch to side-by-side view
--- a
+++ b/trunk/bignum.h
@@ -0,0 +1,498 @@
+// Copyright (c) 2009 Satoshi Nakamoto
+// Distributed under the MIT/X11 software license, see the accompanying
+// file license.txt or http://www.opensource.org/licenses/mit-license.php.
+
+#include <stdexcept>
+#include <vector>
+#include <openssl/bn.h>
+
+
+
+
+
+class bignum_error : public std::runtime_error
+{
+public:
+    explicit bignum_error(const std::string& str) : std::runtime_error(str) {}
+};
+
+
+
+class CAutoBN_CTX
+{
+protected:
+    BN_CTX* pctx;
+    BN_CTX* operator=(BN_CTX* pnew) { return pctx = pnew; }
+
+public:
+    CAutoBN_CTX()
+    {
+        pctx = BN_CTX_new();
+        if (pctx == NULL)
+            throw bignum_error("CAutoBN_CTX : BN_CTX_new() returned NULL");
+    }
+
+    ~CAutoBN_CTX()
+    {
+        if (pctx != NULL)
+            BN_CTX_free(pctx);
+    }
+
+    operator BN_CTX*() { return pctx; }
+    BN_CTX& operator*() { return *pctx; }
+    BN_CTX** operator&() { return &pctx; }
+    bool operator!() { return (pctx == NULL); }
+};
+
+
+
+class CBigNum : public BIGNUM
+{
+public:
+    CBigNum()
+    {
+        BN_init(this);
+    }
+
+    CBigNum(const CBigNum& b)
+    {
+        BN_init(this);
+        if (!BN_copy(this, &b))
+        {
+            BN_clear_free(this);
+            throw bignum_error("CBigNum::CBigNum(const CBigNum&) : BN_copy failed");
+        }
+    }
+
+    explicit CBigNum(const std::string& str)
+    {
+        BN_init(this);
+        SetHex(str);
+    }
+
+    CBigNum& operator=(const CBigNum& b)
+    {
+        if (!BN_copy(this, &b))
+            throw bignum_error("CBigNum::operator= : BN_copy failed");
+        return (*this);
+    }
+
+    ~CBigNum()
+    {
+        BN_clear_free(this);
+    }
+
+    CBigNum(char n)             { BN_init(this); if (n >= 0) setulong(n); else setint64(n); }
+    CBigNum(short n)            { BN_init(this); if (n >= 0) setulong(n); else setint64(n); }
+    CBigNum(int n)              { BN_init(this); if (n >= 0) setulong(n); else setint64(n); }
+    CBigNum(long n)             { BN_init(this); if (n >= 0) setulong(n); else setint64(n); }
+    CBigNum(int64 n)            { BN_init(this); setint64(n); }
+    CBigNum(unsigned char n)    { BN_init(this); setulong(n); }
+    CBigNum(unsigned short n)   { BN_init(this); setulong(n); }
+    CBigNum(unsigned int n)     { BN_init(this); setulong(n); }
+    CBigNum(unsigned long n)    { BN_init(this); setulong(n); }
+    CBigNum(uint64 n)           { BN_init(this); setuint64(n); }
+    explicit CBigNum(uint256 n) { BN_init(this); setuint256(n); }
+
+    explicit CBigNum(const std::vector<unsigned char>& vch)
+    {
+        BN_init(this);
+        setvch(vch);
+    }
+
+    void setulong(unsigned long n)
+    {
+        if (!BN_set_word(this, n))
+            throw bignum_error("CBigNum conversion from unsigned long : BN_set_word failed");
+    }
+
+    unsigned long getulong() const
+    {
+        return BN_get_word(this);
+    }
+
+    unsigned int getuint() const
+    {
+        return BN_get_word(this);
+    }
+
+    int getint() const
+    {
+        unsigned long n = BN_get_word(this);
+        if (!BN_is_negative(this))
+            return (n > INT_MAX ? INT_MAX : n);
+        else
+            return (n > INT_MAX ? INT_MIN : -(int)n);
+    }
+
+    void setint64(int64 n)
+    {
+        unsigned char pch[sizeof(n) + 6];
+        unsigned char* p = pch + 4;
+        bool fNegative = false;
+        if (n < (int64)0)
+        {
+            n = -n;
+            fNegative = true;
+        }
+        bool fLeadingZeroes = true;
+        for (int i = 0; i < 8; i++)
+        {
+            unsigned char c = (n >> 56) & 0xff;
+            n <<= 8;
+            if (fLeadingZeroes)
+            {
+                if (c == 0)
+                    continue;
+                if (c & 0x80)
+                    *p++ = (fNegative ? 0x80 : 0);
+                else if (fNegative)
+                    c |= 0x80;
+                fLeadingZeroes = false;
+            }
+            *p++ = c;
+        }
+        unsigned int nSize = p - (pch + 4);
+        pch[0] = (nSize >> 24) & 0xff;
+        pch[1] = (nSize >> 16) & 0xff;
+        pch[2] = (nSize >> 8) & 0xff;
+        pch[3] = (nSize) & 0xff;
+        BN_mpi2bn(pch, p - pch, this);
+    }
+
+    void setuint64(uint64 n)
+    {
+        unsigned char pch[sizeof(n) + 6];
+        unsigned char* p = pch + 4;
+        bool fLeadingZeroes = true;
+        for (int i = 0; i < 8; i++)
+        {
+            unsigned char c = (n >> 56) & 0xff;
+            n <<= 8;
+            if (fLeadingZeroes)
+            {
+                if (c == 0)
+                    continue;
+                if (c & 0x80)
+                    *p++ = 0;
+                fLeadingZeroes = false;
+            }
+            *p++ = c;
+        }
+        unsigned int nSize = p - (pch + 4);
+        pch[0] = (nSize >> 24) & 0xff;
+        pch[1] = (nSize >> 16) & 0xff;
+        pch[2] = (nSize >> 8) & 0xff;
+        pch[3] = (nSize) & 0xff;
+        BN_mpi2bn(pch, p - pch, this);
+    }
+
+    void setuint256(uint256 n)
+    {
+        unsigned char pch[sizeof(n) + 6];
+        unsigned char* p = pch + 4;
+        bool fLeadingZeroes = true;
+        unsigned char* pbegin = (unsigned char*)&n;
+        unsigned char* psrc = pbegin + sizeof(n);
+        while (psrc != pbegin)
+        {
+            unsigned char c = *(--psrc);
+            if (fLeadingZeroes)
+            {
+                if (c == 0)
+                    continue;
+                if (c & 0x80)
+                    *p++ = 0;
+                fLeadingZeroes = false;
+            }
+            *p++ = c;
+        }
+        unsigned int nSize = p - (pch + 4);
+        pch[0] = (nSize >> 24) & 0xff;
+        pch[1] = (nSize >> 16) & 0xff;
+        pch[2] = (nSize >> 8) & 0xff;
+        pch[3] = (nSize >> 0) & 0xff;
+        BN_mpi2bn(pch, p - pch, this);
+    }
+
+    uint256 getuint256()
+    {
+        unsigned int nSize = BN_bn2mpi(this, NULL);
+        if (nSize < 4)
+            return 0;
+        std::vector<unsigned char> vch(nSize);
+        BN_bn2mpi(this, &vch[0]);
+        if (vch.size() > 4)
+            vch[4] &= 0x7f;
+        uint256 n = 0;
+        for (int i = 0, j = vch.size()-1; i < sizeof(n) && j >= 4; i++, j--)
+            ((unsigned char*)&n)[i] = vch[j];
+        return n;
+    }
+
+    void setvch(const std::vector<unsigned char>& vch)
+    {
+        std::vector<unsigned char> vch2(vch.size() + 4);
+        unsigned int nSize = vch.size();
+        vch2[0] = (nSize >> 24) & 0xff;
+        vch2[1] = (nSize >> 16) & 0xff;
+        vch2[2] = (nSize >> 8) & 0xff;
+        vch2[3] = (nSize >> 0) & 0xff;
+        reverse_copy(vch.begin(), vch.end(), vch2.begin() + 4);
+        BN_mpi2bn(&vch2[0], vch2.size(), this);
+    }
+
+    std::vector<unsigned char> getvch() const
+    {
+        unsigned int nSize = BN_bn2mpi(this, NULL);
+        if (nSize < 4)
+            return std::vector<unsigned char>();
+        std::vector<unsigned char> vch(nSize);
+        BN_bn2mpi(this, &vch[0]);
+        vch.erase(vch.begin(), vch.begin() + 4);
+        reverse(vch.begin(), vch.end());
+        return vch;
+    }
+
+    CBigNum& SetCompact(unsigned int nCompact)
+    {
+        unsigned int nSize = nCompact >> 24;
+        std::vector<unsigned char> vch(4 + nSize);
+        vch[3] = nSize;
+        if (nSize >= 1) vch[4] = (nCompact >> 16) & 0xff;
+        if (nSize >= 2) vch[5] = (nCompact >> 8) & 0xff;
+        if (nSize >= 3) vch[6] = (nCompact >> 0) & 0xff;
+        BN_mpi2bn(&vch[0], vch.size(), this);
+        return *this;
+    }
+
+    unsigned int GetCompact() const
+    {
+        unsigned int nSize = BN_bn2mpi(this, NULL);
+        std::vector<unsigned char> vch(nSize);
+        nSize -= 4;
+        BN_bn2mpi(this, &vch[0]);
+        unsigned int nCompact = nSize << 24;
+        if (nSize >= 1) nCompact |= (vch[4] << 16);
+        if (nSize >= 2) nCompact |= (vch[5] << 8);
+        if (nSize >= 3) nCompact |= (vch[6] << 0);
+        return nCompact;
+    }
+
+    void SetHex(const std::string& str)
+    {
+        // skip 0x
+        const char* psz = str.c_str();
+        while (isspace(*psz))
+            psz++;
+        bool fNegative = false;
+        if (*psz == '-')
+        {
+            fNegative = true;
+            psz++;
+        }
+        if (psz[0] == '0' && tolower(psz[1]) == 'x')
+            psz += 2;
+        while (isspace(*psz))
+            psz++;
+
+        // hex string to bignum
+        static char phexdigit[256] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0 };
+        *this = 0;
+        while (isxdigit(*psz))
+        {
+            *this <<= 4;
+            int n = phexdigit[*psz++];
+            *this += n;
+        }
+        if (fNegative)
+            *this = 0 - *this;
+    }
+
+    unsigned int GetSerializeSize(int nType=0, int nVersion=VERSION) const
+    {
+        return ::GetSerializeSize(getvch(), nType, nVersion);
+    }
+
+    template<typename Stream>
+    void Serialize(Stream& s, int nType=0, int nVersion=VERSION) const
+    {
+        ::Serialize(s, getvch(), nType, nVersion);
+    }
+
+    template<typename Stream>
+    void Unserialize(Stream& s, int nType=0, int nVersion=VERSION)
+    {
+        vector<unsigned char> vch;
+        ::Unserialize(s, vch, nType, nVersion);
+        setvch(vch);
+    }
+
+
+    bool operator!() const
+    {
+        return BN_is_zero(this);
+    }
+
+    CBigNum& operator+=(const CBigNum& b)
+    {
+        if (!BN_add(this, this, &b))
+            throw bignum_error("CBigNum::operator+= : BN_add failed");
+        return *this;
+    }
+
+    CBigNum& operator-=(const CBigNum& b)
+    {
+        *this = *this - b;
+        return *this;
+    }
+
+    CBigNum& operator*=(const CBigNum& b)
+    {
+        CAutoBN_CTX pctx;
+        if (!BN_mul(this, this, &b, pctx))
+            throw bignum_error("CBigNum::operator*= : BN_mul failed");
+        return *this;
+    }
+
+    CBigNum& operator/=(const CBigNum& b)
+    {
+        *this = *this / b;
+        return *this;
+    }
+
+    CBigNum& operator%=(const CBigNum& b)
+    {
+        *this = *this % b;
+        return *this;
+    }
+
+    CBigNum& operator<<=(unsigned int shift)
+    {
+        if (!BN_lshift(this, this, shift))
+            throw bignum_error("CBigNum:operator<<= : BN_lshift failed");
+        return *this;
+    }
+
+    CBigNum& operator>>=(unsigned int shift)
+    {
+        if (!BN_rshift(this, this, shift))
+            throw bignum_error("CBigNum:operator>>= : BN_rshift failed");
+        return *this;
+    }
+
+
+    CBigNum& operator++()
+    {
+        // prefix operator
+        if (!BN_add(this, this, BN_value_one()))
+            throw bignum_error("CBigNum::operator++ : BN_add failed");
+        return *this;
+    }
+
+    const CBigNum operator++(int)
+    {
+        // postfix operator
+        const CBigNum ret = *this;
+        ++(*this);
+        return ret;
+    }
+
+    CBigNum& operator--()
+    {
+        // prefix operator
+        CBigNum r;
+        if (!BN_sub(&r, this, BN_value_one()))
+            throw bignum_error("CBigNum::operator-- : BN_sub failed");
+        *this = r;
+        return *this;
+    }
+
+    const CBigNum operator--(int)
+    {
+        // postfix operator
+        const CBigNum ret = *this;
+        --(*this);
+        return ret;
+    }
+
+
+    friend inline const CBigNum operator-(const CBigNum& a, const CBigNum& b);
+    friend inline const CBigNum operator/(const CBigNum& a, const CBigNum& b);
+    friend inline const CBigNum operator%(const CBigNum& a, const CBigNum& b);
+};
+
+
+
+inline const CBigNum operator+(const CBigNum& a, const CBigNum& b)
+{
+    CBigNum r;
+    if (!BN_add(&r, &a, &b))
+        throw bignum_error("CBigNum::operator+ : BN_add failed");
+    return r;
+}
+
+inline const CBigNum operator-(const CBigNum& a, const CBigNum& b)
+{
+    CBigNum r;
+    if (!BN_sub(&r, &a, &b))
+        throw bignum_error("CBigNum::operator- : BN_sub failed");
+    return r;
+}
+
+inline const CBigNum operator-(const CBigNum& a)
+{
+    CBigNum r(a);
+    BN_set_negative(&r, !BN_is_negative(&r));
+    return r;
+}
+
+inline const CBigNum operator*(const CBigNum& a, const CBigNum& b)
+{
+    CAutoBN_CTX pctx;
+    CBigNum r;
+    if (!BN_mul(&r, &a, &b, pctx))
+        throw bignum_error("CBigNum::operator* : BN_mul failed");
+    return r;
+}
+
+inline const CBigNum operator/(const CBigNum& a, const CBigNum& b)
+{
+    CAutoBN_CTX pctx;
+    CBigNum r;
+    if (!BN_div(&r, NULL, &a, &b, pctx))
+        throw bignum_error("CBigNum::operator/ : BN_div failed");
+    return r;
+}
+
+inline const CBigNum operator%(const CBigNum& a, const CBigNum& b)
+{
+    CAutoBN_CTX pctx;
+    CBigNum r;
+    if (!BN_mod(&r, &a, &b, pctx))
+        throw bignum_error("CBigNum::operator% : BN_div failed");
+    return r;
+}
+
+inline const CBigNum operator<<(const CBigNum& a, unsigned int shift)
+{
+    CBigNum r;
+    if (!BN_lshift(&r, &a, shift))
+        throw bignum_error("CBigNum:operator<< : BN_lshift failed");
+    return r;
+}
+
+inline const CBigNum operator>>(const CBigNum& a, unsigned int shift)
+{
+    CBigNum r;
+    if (!BN_rshift(&r, &a, shift))
+        throw bignum_error("CBigNum:operator>> : BN_rshift failed");
+    return r;
+}
+
+inline bool operator==(const CBigNum& a, const CBigNum& b) { return (BN_cmp(&a, &b) == 0); }
+inline bool operator!=(const CBigNum& a, const CBigNum& b) { return (BN_cmp(&a, &b) != 0); }
+inline bool operator<=(const CBigNum& a, const CBigNum& b) { return (BN_cmp(&a, &b) <= 0); }
+inline bool operator>=(const CBigNum& a, const CBigNum& b) { return (BN_cmp(&a, &b) >= 0); }
+inline bool operator<(const CBigNum& a, const CBigNum& b)  { return (BN_cmp(&a, &b) < 0); }
+inline bool operator>(const CBigNum& a, const CBigNum& b)  { return (BN_cmp(&a, &b) > 0); }
/trunk/db.cpp Diff Switch to side-by-side view
--- a
+++ b/trunk/db.cpp
@@ -0,0 +1,614 @@
+// Copyright (c) 2009 Satoshi Nakamoto
+// Distributed under the MIT/X11 software license, see the accompanying
+// file license.txt or http://www.opensource.org/licenses/mit-license.php.
+
+#include "headers.h"
+
+
+
+
+
+
+//
+// CDB
+//
+
+static CCriticalSection cs_db;
+static bool fDbEnvInit = false;
+DbEnv dbenv(0);
+static map<string, int> mapFileUseCount;
+
+class CDBInit
+{
+public:
+    CDBInit()
+    {
+    }
+    ~CDBInit()
+    {
+        if (fDbEnvInit)
+        {
+            dbenv.close(0);
+            fDbEnvInit = false;
+        }
+    }
+}
+instance_of_cdbinit;
+
+
+CDB::CDB(const char* pszFile, const char* pszMode, bool fTxn) : pdb(NULL)
+{
+    int ret;
+    if (pszFile == NULL)
+        return;
+
+    bool fCreate = strchr(pszMode, 'c');
+    bool fReadOnly = (!strchr(pszMode, '+') && !strchr(pszMode, 'w'));
+    unsigned int nFlags = DB_THREAD;
+    if (fCreate)
+        nFlags |= DB_CREATE;
+    else if (fReadOnly)
+        nFlags |= DB_RDONLY;
+    if (!fReadOnly || fTxn)
+        nFlags |= DB_AUTO_COMMIT;
+
+    CRITICAL_BLOCK(cs_db)
+    {
+        if (!fDbEnvInit)
+        {
+            string strAppDir = GetAppDir();
+            string strLogDir = strAppDir + "\\database";
+            _mkdir(strLogDir.c_str());
+            printf("dbenv.open strAppDir=%s\n", strAppDir.c_str());
+
+            dbenv.set_lg_dir(strLogDir.c_str());
+            dbenv.set_lg_max(10000000);
+            dbenv.set_lk_max_locks(10000);
+            dbenv.set_lk_max_objects(10000);
+            dbenv.set_errfile(fopen("db.log", "a")); /// debug
+            ///dbenv.log_set_config(DB_LOG_AUTO_REMOVE, 1); /// causes corruption
+            ret = dbenv.open(strAppDir.c_str(),
+                             DB_CREATE     |
+                             DB_INIT_LOCK  |
+                             DB_INIT_LOG   |
+                             DB_INIT_MPOOL |
+                             DB_INIT_TXN   |
+                             DB_THREAD     |
+                             DB_PRIVATE    |
+                             DB_RECOVER,
+                             0);
+            if (ret > 0)
+                throw runtime_error(strprintf("CDB() : error %d opening database environment\n", ret));
+            fDbEnvInit = true;
+        }
+
+        strFile = pszFile;
+        ++mapFileUseCount[strFile];
+    }
+
+    pdb = new Db(&dbenv, 0);
+
+    ret = pdb->open(NULL,      // Txn pointer
+                    pszFile,   // Filename
+                    "main",    // Logical db name
+                    DB_BTREE,  // Database type
+                    nFlags,    // Flags
+                    0);
+
+    if (ret > 0)
+    {
+        delete pdb;
+        pdb = NULL;
+        CRITICAL_BLOCK(cs_db)
+            --mapFileUseCount[strFile];
+        strFile = "";
+        throw runtime_error(strprintf("CDB() : can't open database file %s, error %d\n", pszFile, ret));
+    }
+
+    if (fCreate && !Exists(string("version")))
+        WriteVersion(VERSION);
+
+    RandAddSeed();
+}
+
+void CDB::Close()
+{
+    if (!pdb)
+        return;
+    if (!vTxn.empty())
+        vTxn.front()->abort();
+    vTxn.clear();
+    pdb->close(0);
+    delete pdb;
+    pdb = NULL;
+    dbenv.txn_checkpoint(0, 0, 0);
+
+    CRITICAL_BLOCK(cs_db)
+        --mapFileUseCount[strFile];
+
+    RandAddSeed();
+}
+
+void DBFlush(bool fShutdown)
+{
+    // Flush log data to the actual data file
+    //  on all files that are not in use
+    printf("DBFlush(%s)\n", fShutdown ? "true" : "false");
+    CRITICAL_BLOCK(cs_db)
+    {
+        dbenv.txn_checkpoint(0, 0, 0);
+        map<string, int>::iterator mi = mapFileUseCount.begin();
+        while (mi != mapFileUseCount.end())
+        {
+            string strFile = (*mi).first;
+            int nRefCount = (*mi).second;
+            if (nRefCount == 0)
+            {
+                dbenv.lsn_reset(strFile.c_str(), 0);
+                mapFileUseCount.erase(mi++);
+            }
+            else
+                mi++;
+        }
+        if (fShutdown)
+        {
+            char** listp;
+            if (mapFileUseCount.empty())
+                dbenv.log_archive(&listp, DB_ARCH_REMOVE);
+            dbenv.close(0);
+            fDbEnvInit = false;
+        }
+    }
+}
+
+
+
+
+
+
+//
+// CTxDB
+//
+
+bool CTxDB::ReadTxIndex(uint256 hash, CTxIndex& txindex)
+{
+    assert(!fClient);
+    txindex.SetNull();
+    return Read(make_pair(string("tx"), hash), txindex);
+}
+
+bool CTxDB::UpdateTxIndex(uint256 hash, const CTxIndex& txindex)
+{
+    assert(!fClient);
+    return Write(make_pair(string("tx"), hash), txindex);
+}
+
+bool CTxDB::AddTxIndex(const CTransaction& tx, const CDiskTxPos& pos, int nHeight)
+{
+    assert(!fClient);
+
+    // Add to tx index
+    uint256 hash = tx.GetHash();
+    CTxIndex txindex(pos, tx.vout.size());
+    return Write(make_pair(string("tx"), hash), txindex);
+}
+
+bool CTxDB::EraseTxIndex(const CTransaction& tx)
+{
+    assert(!fClient);
+    uint256 hash = tx.GetHash();
+
+    return Erase(make_pair(string("tx"), hash));
+}
+
+bool CTxDB::ContainsTx(uint256 hash)
+{
+    assert(!fClient);
+    return Exists(make_pair(string("tx"), hash));
+}
+
+bool CTxDB::ReadOwnerTxes(uint160 hash160, int nMinHeight, vector<CTransaction>& vtx)
+{
+    assert(!fClient);
+    vtx.clear();
+
+    // Get cursor
+    Dbc* pcursor = GetCursor();
+    if (!pcursor)
+        return false;
+
+    unsigned int fFlags = DB_SET_RANGE;
+    loop
+    {
+        // Read next record
+        CDataStream ssKey;
+        if (fFlags == DB_SET_RANGE)
+            ssKey << string("owner") << hash160 << CDiskTxPos(0, 0, 0);
+        CDataStream ssValue;
+        int ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);
+        fFlags = DB_NEXT;
+        if (ret == DB_NOTFOUND)
+            break;
+        else if (ret != 0)
+            return false;
+
+        // Unserialize
+        string strType;
+        uint160 hashItem;
+        CDiskTxPos pos;
+        ssKey >> strType >> hashItem >> pos;
+        int nItemHeight;
+        ssValue >> nItemHeight;
+
+        // Read transaction
+        if (strType != "owner" || hashItem != hash160)
+            break;
+        if (nItemHeight >= nMinHeight)
+        {
+            vtx.resize(vtx.size()+1);
+            if (!vtx.back().ReadFromDisk(pos))
+                return false;
+        }
+    }
+    return true;
+}
+
+bool CTxDB::ReadDiskTx(uint256 hash, CTransaction& tx, CTxIndex& txindex)
+{
+    assert(!fClient);
+    tx.SetNull();
+    if (!ReadTxIndex(hash, txindex))
+        return false;
+    return (tx.ReadFromDisk(txindex.pos));
+}
+
+bool CTxDB::ReadDiskTx(uint256 hash, CTransaction& tx)
+{
+    CTxIndex txindex;
+    return ReadDiskTx(hash, tx, txindex);
+}
+
+bool CTxDB::ReadDiskTx(COutPoint outpoint, CTransaction& tx, CTxIndex& txindex)
+{
+    return ReadDiskTx(outpoint.hash, tx, txindex);
+}
+
+bool CTxDB::ReadDiskTx(COutPoint outpoint, CTransaction& tx)
+{
+    CTxIndex txindex;
+    return ReadDiskTx(outpoint.hash, tx, txindex);
+}
+
+bool CTxDB::WriteBlockIndex(const CDiskBlockIndex& blockindex)
+{
+    return Write(make_pair(string("blockindex"), blockindex.GetBlockHash()), blockindex);
+}
+
+bool CTxDB::EraseBlockIndex(uint256 hash)
+{
+    return Erase(make_pair(string("blockindex"), hash));
+}
+
+bool CTxDB::ReadHashBestChain(uint256& hashBestChain)
+{
+    return Read(string("hashBestChain"), hashBestChain);
+}
+
+bool CTxDB::WriteHashBestChain(uint256 hashBestChain)
+{
+    return Write(string("hashBestChain"), hashBestChain);
+}
+
+CBlockIndex* InsertBlockIndex(uint256 hash)
+{
+    if (hash == 0)
+        return NULL;
+
+    // Return existing
+    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);
+    if (mi != mapBlockIndex.end())
+        return (*mi).second;
+
+    // Create new
+    CBlockIndex* pindexNew = new CBlockIndex();
+    if (!pindexNew)
+        throw runtime_error("LoadBlockIndex() : new CBlockIndex failed");
+    mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;
+    pindexNew->phashBlock = &((*mi).first);
+
+    return pindexNew;
+}
+
+bool CTxDB::LoadBlockIndex()
+{
+    // Get cursor
+    Dbc* pcursor = GetCursor();
+    if (!pcursor)
+        return false;
+
+    unsigned int fFlags = DB_SET_RANGE;
+    loop
+    {
+        // Read next record
+        CDataStream ssKey;
+        if (fFlags == DB_SET_RANGE)
+            ssKey << make_pair(string("blockindex"), uint256(0));
+        CDataStream ssValue;
+        int ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);
+        fFlags = DB_NEXT;
+        if (ret == DB_NOTFOUND)
+            break;
+        else if (ret != 0)
+            return false;
+
+        // Unserialize
+        string strType;
+        ssKey >> strType;
+        if (strType == "blockindex")
+        {
+            CDiskBlockIndex diskindex;
+            ssValue >> diskindex;
+
+            // Construct block index object
+            CBlockIndex* pindexNew = InsertBlockIndex(diskindex.GetBlockHash());
+            pindexNew->pprev          = InsertBlockIndex(diskindex.hashPrev);
+            pindexNew->pnext          = InsertBlockIndex(diskindex.hashNext);
+            pindexNew->nFile          = diskindex.nFile;
+            pindexNew->nBlockPos      = diskindex.nBlockPos;
+            pindexNew->nHeight        = diskindex.nHeight;
+            pindexNew->nVersion       = diskindex.nVersion;
+            pindexNew->hashMerkleRoot = diskindex.hashMerkleRoot;
+            pindexNew->nTime          = diskindex.nTime;
+            pindexNew->nBits          = diskindex.nBits;
+            pindexNew->nNonce         = diskindex.nNonce;
+
+            // Watch for genesis block and best block
+            if (pindexGenesisBlock == NULL && diskindex.GetBlockHash() == hashGenesisBlock)
+                pindexGenesisBlock = pindexNew;
+        }
+        else
+        {
+            break;
+        }
+    }
+
+    if (!ReadHashBestChain(hashBestChain))
+    {
+        if (pindexGenesisBlock == NULL)
+            return true;
+        return error("CTxDB::LoadBlockIndex() : hashBestChain not found\n");
+    }
+
+    if (!mapBlockIndex.count(hashBestChain))
+        return error("CTxDB::LoadBlockIndex() : blockindex for hashBestChain not found\n");
+    pindexBest = mapBlockIndex[hashBestChain];
+    nBestHeight = pindexBest->nHeight;
+    printf("LoadBlockIndex(): hashBestChain=%s  height=%d\n", hashBestChain.ToString().substr(0,14).c_str(), nBestHeight);
+
+    return true;
+}
+
+
+
+
+
+//
+// CAddrDB
+//
+
+bool CAddrDB::WriteAddress(const CAddress& addr)
+{
+    return Write(make_pair(string("addr"), addr.GetKey()), addr);
+}
+
+bool CAddrDB::LoadAddresses()
+{
+    CRITICAL_BLOCK(cs_mapIRCAddresses)
+    CRITICAL_BLOCK(cs_mapAddresses)
+    {
+        // Load user provided addresses
+        CAutoFile filein = fopen("addr.txt", "rt");
+        if (filein)
+        {
+            try
+            {
+                char psz[1000];
+                while (fgets(psz, sizeof(psz), filein))
+                {
+                    CAddress addr(psz, NODE_NETWORK);
+                    if (addr.ip != 0)
+                    {
+                        AddAddress(*this, addr);
+                        mapIRCAddresses.insert(make_pair(addr.GetKey(), addr));
+                    }
+                }
+            }
+            catch (...) { }
+        }
+
+        // Get cursor
+        Dbc* pcursor = GetCursor();
+        if (!pcursor)
+            return false;
+
+        loop
+        {
+            // Read next record
+            CDataStream ssKey;
+            CDataStream ssValue;
+            int ret = ReadAtCursor(pcursor, ssKey, ssValue);
+            if (ret == DB_NOTFOUND)
+                break;
+            else if (ret != 0)
+                return false;
+
+            // Unserialize
+            string strType;
+            ssKey >> strType;
+            if (strType == "addr")
+            {
+                CAddress addr;
+                ssValue >> addr;
+                mapAddresses.insert(make_pair(addr.GetKey(), addr));
+            }
+        }
+
+        //// debug print
+        printf("mapAddresses:\n");
+        foreach(const PAIRTYPE(vector<unsigned char>, CAddress)& item, mapAddresses)
+            item.second.print();
+        printf("-----\n");
+
+        // Fix for possible bug that manifests in mapAddresses.count in irc.cpp,
+        // just need to call count here and it doesn't happen there.  The bug was the
+        // pack pragma in irc.cpp and has been fixed, but I'm not in a hurry to delete this.
+        mapAddresses.count(vector<unsigned char>(18));
+    }
+
+    return true;
+}
+
+bool LoadAddresses()
+{
+    return CAddrDB("cr+").LoadAddresses();
+}
+
+
+
+
+//
+// CReviewDB
+//
+
+bool CReviewDB::ReadReviews(uint256 hash, vector<CReview>& vReviews)
+{
+    vReviews.size(); // msvc workaround, just need to do anything with vReviews
+    return Read(make_pair(string("reviews"), hash), vReviews);
+}
+
+bool CReviewDB::WriteReviews(uint256 hash, const vector<CReview>& vReviews)
+{
+    return Write(make_pair(string("reviews"), hash), vReviews);
+}
+
+
+
+
+
+
+
+//
+// CWalletDB
+//
+
+bool CWalletDB::LoadWallet(vector<unsigned char>& vchDefaultKeyRet)
+{
+    vchDefaultKeyRet.clear();
+
+    //// todo: shouldn't we catch exceptions and try to recover and continue?
+    CRITICAL_BLOCK(cs_mapKeys)
+    CRITICAL_BLOCK(cs_mapWallet)
+    {
+        // Get cursor
+        Dbc* pcursor = GetCursor();
+        if (!pcursor)
+            return false;
+
+        loop
+        {
+            // Read next record
+            CDataStream ssKey;
+            CDataStream ssValue;
+            int ret = ReadAtCursor(pcursor, ssKey, ssValue);
+            if (ret == DB_NOTFOUND)
+                break;
+            else if (ret != 0)
+                return false;
+
+            // Unserialize
+            // Taking advantage of the fact that pair serialization
+            // is just the two items serialized one after the other
+            string strType;
+            ssKey >> strType;
+            if (strType == "name")
+            {
+                string strAddress;
+                ssKey >> strAddress;
+                ssValue >> mapAddressBook[strAddress];
+            }
+            else if (strType == "tx")
+            {
+                uint256 hash;
+                ssKey >> hash;
+                CWalletTx& wtx = mapWallet[hash];
+                ssValue >> wtx;
+
+                if (wtx.GetHash() != hash)
+                    printf("Error in wallet.dat, hash mismatch\n");
+
+                //// debug print
+                //printf("LoadWallet  %s\n", wtx.GetHash().ToString().c_str());
+                //printf(" %12I64d  %s  %s  %s\n",
+                //    wtx.vout[0].nValue,
+                //    DateTimeStr(wtx.nTime).c_str(),
+                //    wtx.hashBlock.ToString().substr(0,14).c_str(),
+                //    wtx.mapValue["message"].c_str());
+            }
+            else if (strType == "key")
+            {
+                vector<unsigned char> vchPubKey;
+                ssKey >> vchPubKey;
+                CPrivKey vchPrivKey;
+                ssValue >> vchPrivKey;
+
+                mapKeys[vchPubKey] = vchPrivKey;
+                mapPubKeys[Hash160(vchPubKey)] = vchPubKey;
+            }
+            else if (strType == "defaultkey")
+            {
+                ssValue >> vchDefaultKeyRet;
+            }
+            else if (strType == "setting")  /// or settings or option or options or config?
+            {
+                string strKey;
+                ssKey >> strKey;
+                if (strKey == "fGenerateBitcoins")  ssValue >> fGenerateBitcoins;
+                if (strKey == "nTransactionFee")    ssValue >> nTransactionFee;
+                if (strKey == "addrIncoming")       ssValue >> addrIncoming;
+            }
+        }
+    }
+
+    printf("fGenerateBitcoins = %d\n", fGenerateBitcoins);
+    printf("nTransactionFee = %I64d\n", nTransactionFee);
+    printf("addrIncoming = %s\n", addrIncoming.ToString().c_str());
+
+    return true;
+}
+
+bool LoadWallet()
+{
+    vector<unsigned char> vchDefaultKey;
+    if (!CWalletDB("cr").LoadWallet(vchDefaultKey))
+        return false;
+
+    if (mapKeys.count(vchDefaultKey))
+    {
+        // Set keyUser
+        keyUser.SetPubKey(vchDefaultKey);
+        keyUser.SetPrivKey(mapKeys[vchDefaultKey]);
+    }
+    else
+    {
+        // Create new keyUser and set as default key
+        RandAddSeed(true);
+        keyUser.MakeNewKey();
+        if (!AddKey(keyUser))
+            return false;
+        if (!SetAddressBookName(PubKeyToAddress(keyUser.GetPubKey()), "Your Address"))
+            return false;
+        CWalletDB().WriteDefaultKey(keyUser.GetPubKey());
+    }
+
+    return true;
+}
/trunk/db.h Diff Switch to side-by-side view
--- a
+++ b/trunk/db.h
@@ -0,0 +1,420 @@
+// Copyright (c) 2009 Satoshi Nakamoto
+// Distributed under the MIT/X11 software license, see the accompanying
+// file license.txt or http://www.opensource.org/licenses/mit-license.php.
+
+#include <db_cxx.h>
+class CTransaction;
+class CTxIndex;
+class CDiskBlockIndex;
+class CDiskTxPos;
+class COutPoint;
+class CUser;
+class CReview;
+class CAddress;
+class CWalletTx;
+
+extern map<string, string> mapAddressBook;
+extern bool fClient;
+
+
+extern DbEnv dbenv;
+extern void DBFlush(bool fShutdown);
+
+
+
+
+class CDB
+{
+protected:
+    Db* pdb;
+    string strFile;
+    vector<DbTxn*> vTxn;
+
+    explicit CDB(const char* pszFile, const char* pszMode="r+", bool fTxn=false);
+    ~CDB() { Close(); }
+public:
+    void Close();
+private:
+    CDB(const CDB&);
+    void operator=(const CDB&);
+
+protected:
+    template<typename K, typename T>
+    bool Read(const K& key, T& value)
+    {
+        if (!pdb)
+            return false;
+
+        // Key
+        CDataStream ssKey(SER_DISK);
+        ssKey.reserve(1000);
+        ssKey << key;
+        Dbt datKey(&ssKey[0], ssKey.size());
+
+        // Read
+        Dbt datValue;
+        datValue.set_flags(DB_DBT_MALLOC);
+        int ret = pdb->get(GetTxn(), &datKey, &datValue, 0);
+        memset(datKey.get_data(), 0, datKey.get_size());
+        if (datValue.get_data() == NULL)
+            return false;
+
+        // Unserialize value
+        CDataStream ssValue((char*)datValue.get_data(), (char*)datValue.get_data() + datValue.get_size(), SER_DISK);
+        ssValue >> value;
+
+        // Clear and free memory
+        memset(datValue.get_data(), 0, datValue.get_size());
+        free(datValue.get_data());
+        return (ret == 0);
+    }
+
+    template<typename K, typename T>
+    bool Write(const K& key, const T& value, bool fOverwrite=true)
+    {
+        if (!pdb)
+            return false;
+
+        // Key
+        CDataStream ssKey(SER_DISK);
+        ssKey.reserve(1000);
+        ssKey << key;
+        Dbt datKey(&ssKey[0], ssKey.size());
+
+        // Value
+        CDataStream ssValue(SER_DISK);
+        ssValue.reserve(10000);
+        ssValue << value;
+        Dbt datValue(&ssValue[0], ssValue.size());
+
+        // Write
+        int ret = pdb->put(GetTxn(), &datKey, &datValue, (fOverwrite ? 0 : DB_NOOVERWRITE));
+
+        // Clear memory in case it was a private key
+        memset(datKey.get_data(), 0, datKey.get_size());
+        memset(datValue.get_data(), 0, datValue.get_size());
+        return (ret == 0);
+    }
+
+    template<typename K>
+    bool Erase(const K& key)
+    {
+        if (!pdb)
+            return false;
+
+        // Key
+        CDataStream ssKey(SER_DISK);
+        ssKey.reserve(1000);
+        ssKey << key;
+        Dbt datKey(&ssKey[0], ssKey.size());
+
+        // Erase
+        int ret = pdb->del(GetTxn(), &datKey, 0);
+
+        // Clear memory
+        memset(datKey.get_data(), 0, datKey.get_size());
+        return (ret == 0 || ret == DB_NOTFOUND);
+    }
+
+    template<typename K>
+    bool Exists(const K& key)
+    {
+        if (!pdb)
+            return false;
+
+        // Key
+        CDataStream ssKey(SER_DISK);
+        ssKey.reserve(1000);
+        ssKey << key;
+        Dbt datKey(&ssKey[0], ssKey.size());
+
+        // Exists
+        int ret = pdb->exists(GetTxn(), &datKey, 0);
+
+        // Clear memory
+        memset(datKey.get_data(), 0, datKey.get_size());
+        return (ret == 0);
+    }
+
+    Dbc* GetCursor()
+    {
+        if (!pdb)
+            return NULL;
+        Dbc* pcursor = NULL;
+        int ret = pdb->cursor(NULL, &pcursor, 0);
+        if (ret != 0)
+            return NULL;
+        return pcursor;
+    }
+
+    int ReadAtCursor(Dbc* pcursor, CDataStream& ssKey, CDataStream& ssValue, unsigned int fFlags=DB_NEXT)
+    {
+        // Read at cursor
+        Dbt datKey;
+        if (fFlags == DB_SET || fFlags == DB_SET_RANGE || fFlags == DB_GET_BOTH || fFlags == DB_GET_BOTH_RANGE)
+        {
+            datKey.set_data(&ssKey[0]);
+            datKey.set_size(ssKey.size());
+        }
+        Dbt datValue;
+        if (fFlags == DB_GET_BOTH || fFlags == DB_GET_BOTH_RANGE)
+        {
+            datValue.set_data(&ssValue[0]);
+            datValue.set_size(ssValue.size());
+        }
+        datKey.set_flags(DB_DBT_MALLOC);
+        datValue.set_flags(DB_DBT_MALLOC);
+        int ret = pcursor->get(&datKey, &datValue, fFlags);
+        if (ret != 0)
+            return ret;
+        else if (datKey.get_data() == NULL || datValue.get_data() == NULL)
+            return 99999;
+
+        // Convert to streams
+        ssKey.SetType(SER_DISK);
+        ssKey.clear();
+        ssKey.write((char*)datKey.get_data(), datKey.get_size());
+        ssValue.SetType(SER_DISK);
+        ssValue.clear();
+        ssValue.write((char*)datValue.get_data(), datValue.get_size());
+
+        // Clear and free memory
+        memset(datKey.get_data(), 0, datKey.get_size());
+        memset(datValue.get_data(), 0, datValue.get_size());
+        free(datKey.get_data());
+        free(datValue.get_data());
+        return 0;
+    }
+
+    DbTxn* GetTxn()
+    {
+        if (!vTxn.empty())
+            return vTxn.back();
+        else
+            return NULL;
+    }
+
+public:
+    bool TxnBegin()
+    {
+        if (!pdb)
+            return false;
+        DbTxn* ptxn = NULL;
+        int ret = dbenv.txn_begin(GetTxn(), &ptxn, 0);
+        if (!ptxn || ret != 0)
+            return false;
+        vTxn.push_back(ptxn);
+        return true;
+    }
+
+    bool TxnCommit()
+    {
+        if (!pdb)
+            return false;
+        if (vTxn.empty())
+            return false;
+        int ret = vTxn.back()->commit(0);
+        vTxn.pop_back();
+        return (ret == 0);
+    }
+
+    bool TxnAbort()
+    {
+        if (!pdb)
+            return false;
+        if (vTxn.empty())
+            return false;
+        int ret = vTxn.back()->abort();
+        vTxn.pop_back();
+        return (ret == 0);
+    }
+
+    bool ReadVersion(int& nVersion)
+    {
+        nVersion = 0;
+        return Read(string("version"), nVersion);
+    }
+
+    bool WriteVersion(int nVersion)
+    {
+        return Write(string("version"), nVersion);
+    }
+};
+
+
+
+
+
+
+
+
+class CTxDB : public CDB
+{
+public:
+    CTxDB(const char* pszMode="r+", bool fTxn=false) : CDB(!fClient ? "blkindex.dat" : NULL, pszMode, fTxn) { }
+private:
+    CTxDB(const CTxDB&);
+    void operator=(const CTxDB&);
+public:
+    bool ReadTxIndex(uint256 hash, CTxIndex& txindex);
+    bool UpdateTxIndex(uint256 hash, const CTxIndex& txindex);
+    bool AddTxIndex(const CTransaction& tx, const CDiskTxPos& pos, int nHeight);
+    bool EraseTxIndex(const CTransaction& tx);
+    bool ContainsTx(uint256 hash);
+    bool ReadOwnerTxes(uint160 hash160, int nHeight, vector<CTransaction>& vtx);
+    bool ReadDiskTx(uint256 hash, CTransaction& tx, CTxIndex& txindex);
+    bool ReadDiskTx(uint256 hash, CTransaction& tx);
+    bool ReadDiskTx(COutPoint outpoint, CTransaction& tx, CTxIndex& txindex);
+    bool ReadDiskTx(COutPoint outpoint, CTransaction& tx);
+    bool WriteBlockIndex(const CDiskBlockIndex& blockindex);
+    bool EraseBlockIndex(uint256 hash);
+    bool ReadHashBestChain(uint256& hashBestChain);
+    bool WriteHashBestChain(uint256 hashBestChain);
+    bool LoadBlockIndex();
+};
+
+
+
+
+
+class CReviewDB : public CDB
+{
+public:
+    CReviewDB(const char* pszMode="r+", bool fTxn=false) : CDB("reviews.dat", pszMode, fTxn) { }
+private:
+    CReviewDB(const CReviewDB&);
+    void operator=(const CReviewDB&);
+public:
+    bool ReadUser(uint256 hash, CUser& user)
+    {
+        return Read(make_pair(string("user"), hash), user);
+    }
+
+    bool WriteUser(uint256 hash, const CUser& user)
+    {
+        return Write(make_pair(string("user"), hash), user);
+    }
+
+    bool ReadReviews(uint256 hash, vector<CReview>& vReviews);
+    bool WriteReviews(uint256 hash, const vector<CReview>& vReviews);
+};
+
+
+
+
+
+class CMarketDB : public CDB
+{
+public:
+    CMarketDB(const char* pszMode="r+", bool fTxn=false) : CDB("market.dat", pszMode, fTxn) { }
+private:
+    CMarketDB(const CMarketDB&);
+    void operator=(const CMarketDB&);
+};
+
+
+
+
+
+class CAddrDB : public CDB
+{
+public:
+    CAddrDB(const char* pszMode="r+", bool fTxn=false) : CDB("addr.dat", pszMode, fTxn) { }
+private:
+    CAddrDB(const CAddrDB&);
+    void operator=(const CAddrDB&);
+public:
+    bool WriteAddress(const CAddress& addr);
+    bool LoadAddresses();
+};
+
+bool LoadAddresses();
+
+
+
+
+
+class CWalletDB : public CDB
+{
+public:
+    CWalletDB(const char* pszMode="r+", bool fTxn=false) : CDB("wallet.dat", pszMode, fTxn) { }
+private:
+    CWalletDB(const CWalletDB&);
+    void operator=(const CWalletDB&);
+public:
+    bool ReadName(const string& strAddress, string& strName)
+    {
+        strName = "";
+        return Read(make_pair(string("name"), strAddress), strName);
+    }
+
+    bool WriteName(const string& strAddress, const string& strName)
+    {
+        mapAddressBook[strAddress] = strName;
+        return Write(make_pair(string("name"), strAddress), strName);
+    }
+
+    bool EraseName(const string& strAddress)
+    {
+        mapAddressBook.erase(strAddress);
+        return Erase(make_pair(string("name"), strAddress));
+    }
+
+    bool ReadTx(uint256 hash, CWalletTx& wtx)
+    {
+        return Read(make_pair(string("tx"), hash), wtx);
+    }
+
+    bool WriteTx(uint256 hash, const CWalletTx& wtx)
+    {
+        return Write(make_pair(string("tx"), hash), wtx);
+    }
+
+    bool EraseTx(uint256 hash)
+    {
+        return Erase(make_pair(string("tx"), hash));
+    }
+
+    bool ReadKey(const vector<unsigned char>& vchPubKey, CPrivKey& vchPrivKey)
+    {
+        vchPrivKey.clear();
+        return Read(make_pair(string("key"), vchPubKey), vchPrivKey);
+    }
+
+    bool WriteKey(const vector<unsigned char>& vchPubKey, const CPrivKey& vchPrivKey)
+    {
+        return Write(make_pair(string("key"), vchPubKey), vchPrivKey, false);
+    }
+
+    bool ReadDefaultKey(vector<unsigned char>& vchPubKey)
+    {
+        vchPubKey.clear();
+        return Read(string("defaultkey"), vchPubKey);
+    }
+
+    bool WriteDefaultKey(const vector<unsigned char>& vchPubKey)
+    {
+        return Write(string("defaultkey"), vchPubKey);
+    }
+
+    template<typename T>
+    bool ReadSetting(const string& strKey, T& value)
+    {
+        return Read(make_pair(string("setting"), strKey), value);
+    }
+
+    template<typename T>
+    bool WriteSetting(const string& strKey, const T& value)
+    {
+        return Write(make_pair(string("setting"), strKey), value);
+    }
+
+    bool LoadWallet(vector<unsigned char>& vchDefaultKeyRet);
+};
+
+bool LoadWallet();
+
+inline bool SetAddressBookName(const string& strAddress, const string& strName)
+{
+    return CWalletDB().WriteName(strAddress, strName);
+}
/trunk/headers.h Diff Switch to side-by-side view
--- a
+++ b/trunk/headers.h
@@ -0,0 +1,71 @@
+// Copyright (c) 2009 Satoshi Nakamoto
+// Distributed under the MIT/X11 software license, see the accompanying
+// file license.txt or http://www.opensource.org/licenses/mit-license.php.
+
+#ifdef _MSC_VER
+#pragma warning(disable:4786)
+#pragma warning(disable:4804)
+#pragma warning(disable:4717)
+#endif
+#ifdef _WIN32_WINNT
+#undef _WIN32_WINNT
+#endif
+#define _WIN32_WINNT 0x0400
+#define WIN32_LEAN_AND_MEAN 1
+#include <wx/wx.h>
+#include <wx/clipbrd.h>
+#include <wx/snglinst.h>
+#include <openssl/ecdsa.h>
+#include <openssl/evp.h>
+#include <openssl/rand.h>
+#include <openssl/sha.h>
+#include <openssl/ripemd.h>
+#include <windows.h>
+#include <winsock2.h>
+#include <mswsock.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <io.h>
+#include <math.h>
+#include <limits.h>
+#include <float.h>
+#include <assert.h>
+#include <process.h>
+#include <malloc.h>
+#include <memory>
+#define BOUNDSCHECK 1
+#include <sstream>
+#include <string>
+#include <vector>
+#include <list>
+#include <deque>
+#include <map>
+#include <set>
+#include <algorithm>
+#include <numeric>
+#include <boost/foreach.hpp>
+#include <boost/lexical_cast.hpp>
+#include <boost/tuple/tuple.hpp>
+#include <boost/tuple/tuple_comparison.hpp>
+#include <boost/tuple/tuple_io.hpp>
+#include <boost/array.hpp>
+#pragma hdrstop
+using namespace std;
+using namespace boost;
+
+
+
+#include "serialize.h"
+#include "uint256.h"
+#include "util.h"
+#include "key.h"
+#include "bignum.h"
+#include "base58.h"
+#include "script.h"
+#include "db.h"
+#include "net.h"
+#include "irc.h"
+#include "main.h"
+#include "market.h"
+#include "uibase.h"
+#include "ui.h"
/trunk/irc.cpp Diff Switch to side-by-side view
--- a
+++ b/trunk/irc.cpp
@@ -0,0 +1,314 @@
+// Copyright (c) 2009 Satoshi Nakamoto
+// Distributed under the MIT/X11 software license, see the accompanying
+// file license.txt or http://www.opensource.org/licenses/mit-license.php.
+
+#include "headers.h"
+
+
+map<vector<unsigned char>, CAddress> mapIRCAddresses;
+CCriticalSection cs_mapIRCAddresses;
+
+
+
+
+#pragma pack(push, 1)
+struct ircaddr
+{
+    int ip;
+    short port;
+};
+#pragma pack(pop)
+
+string EncodeAddress(const CAddress& addr)
+{
+    struct ircaddr tmp;
+    tmp.ip    = addr.ip;
+    tmp.port  = addr.port;
+
+    vector<unsigned char> vch(UBEGIN(tmp), UEND(tmp));
+    return string("u") + EncodeBase58Check(vch);
+}
+
+bool DecodeAddress(string str, CAddress& addr)
+{
+    vector<unsigned char> vch;
+    if (!DecodeBase58Check(str.substr(1), vch))
+        return false;
+
+    struct ircaddr tmp;
+    if (vch.size() != sizeof(tmp))
+        return false;
+    memcpy(&tmp, &vch[0], sizeof(tmp));
+
+    addr  = CAddress(tmp.ip, tmp.port);
+    return true;
+}
+
+
+
+
+
+
+static bool Send(SOCKET hSocket, const char* pszSend)
+{
+    if (strstr(pszSend, "PONG") != pszSend)
+        printf("SENDING: %s\n", pszSend);
+    const char* psz = pszSend;
+    const char* pszEnd = psz + strlen(psz);
+    while (psz < pszEnd)
+    {
+        int ret = send(hSocket, psz, pszEnd - psz, 0);
+        if (ret < 0)
+            return false;
+        psz += ret;
+    }
+    return true;
+}
+
+bool RecvLine(SOCKET hSocket, string& strLine)
+{
+    strLine = "";
+    loop
+    {
+        char c;
+        int nBytes = recv(hSocket, &c, 1, 0);
+        if (nBytes > 0)
+        {
+            if (c == '\n')
+                continue;
+            if (c == '\r')
+                return true;
+            strLine += c;
+        }
+        else if (nBytes <= 0)
+        {
+            if (!strLine.empty())
+                return true;
+            // socket closed
+            printf("IRC socket closed\n");
+            return false;
+        }
+        else
+        {
+            // socket error
+            int nErr = WSAGetLastError();
+            if (nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)
+            {
+                printf("IRC recv failed: %d\n", nErr);
+                return false;
+            }
+        }
+    }
+}
+
+bool RecvLineIRC(SOCKET hSocket, string& strLine)
+{
+    loop
+    {
+        bool fRet = RecvLine(hSocket, strLine);
+        if (fRet)
+        {
+            if (fShutdown)
+                return false;
+            vector<string> vWords;
+            ParseString(strLine, ' ', vWords);
+            if (vWords[0] == "PING")
+            {
+                strLine[1] = 'O';
+                strLine += '\r';
+                Send(hSocket, strLine.c_str());
+                continue;
+            }
+        }
+        return fRet;
+    }
+}
+
+bool RecvUntil(SOCKET hSocket, const char* psz1, const char* psz2=NULL, const char* psz3=NULL)
+{
+    loop
+    {
+        string strLine;
+        if (!RecvLineIRC(hSocket, strLine))
+            return false;
+        printf("IRC %s\n", strLine.c_str());
+        if (psz1 && strLine.find(psz1) != -1)
+            return true;
+        if (psz2 && strLine.find(psz2) != -1)
+            return true;
+        if (psz3 && strLine.find(psz3) != -1)
+            return true;
+    }
+}
+
+bool Wait(int nSeconds)
+{
+    if (fShutdown)
+        return false;
+    printf("Waiting %d seconds to reconnect to IRC\n", nSeconds);
+    for (int i = 0; i < nSeconds; i++)
+    {
+        if (fShutdown)
+            return false;
+        Sleep(1000);
+    }
+    return true;
+}
+
+
+
+void ThreadIRCSeed(void* parg)
+{
+    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);
+    int nErrorWait = 10;
+    int nRetryWait = 10;
+
+    while (!fShutdown)
+    {
+        CAddress addrConnect("216.155.130.130:6667");
+        struct hostent* phostent = gethostbyname("chat.freenode.net");
+        if (phostent && phostent->h_addr_list && phostent->h_addr_list[0])
+            addrConnect = CAddress(*(u_long*)phostent->h_addr_list[0], htons(6667));
+
+        SOCKET hSocket;
+        if (!ConnectSocket(addrConnect, hSocket))
+        {
+            printf("IRC connect failed\n");
+            nErrorWait = nErrorWait * 11 / 10;
+            if (Wait(nErrorWait += 60))
+                continue;
+            else
+                return;
+        }
+
+        if (!RecvUntil(hSocket, "Found your hostname", "using your IP address instead", "Couldn't look up your hostname"))
+        {
+            closesocket(hSocket);
+            nErrorWait = nErrorWait * 11 / 10;
+            if (Wait(nErrorWait += 60))
+                continue;
+            else
+                return;
+        }
+
+        string strMyName = EncodeAddress(addrLocalHost);
+
+        if (!addrLocalHost.IsRoutable())
+            strMyName = strprintf("x%u", GetRand(1000000000));
+
+
+        Send(hSocket, strprintf("NICK %s\r", strMyName.c_str()).c_str());
+        Send(hSocket, strprintf("USER %s 8 * : %s\r", strMyName.c_str(), strMyName.c_str()).c_str());
+
+        if (!RecvUntil(hSocket, " 004 "))
+        {
+            closesocket(hSocket);
+            nErrorWait = nErrorWait * 11 / 10;
+            if (Wait(nErrorWait += 60))
+                continue;
+            else
+                return;
+        }
+        Sleep(500);
+
+        Send(hSocket, "JOIN #bitcoin\r");
+        Send(hSocket, "WHO #bitcoin\r");
+
+        int64 nStart = GetTime();
+        string strLine;
+        while (!fShutdown && RecvLineIRC(hSocket, strLine))
+        {
+            if (strLine.empty() || strLine.size() > 900 || strLine[0] != ':')
+                continue;
+            printf("IRC %s\n", strLine.c_str());
+
+            vector<string> vWords;
+            ParseString(strLine, ' ', vWords);
+            if (vWords.size() < 2)
+                continue;
+
+            char pszName[10000];
+            pszName[0] = '\0';
+
+            if (vWords[1] == "352" && vWords.size() >= 8)
+            {
+                // index 7 is limited to 16 characters
+                // could get full length name at index 10, but would be different from join messages
+                strcpy(pszName, vWords[7].c_str());
+                printf("GOT WHO: [%s]  ", pszName);
+            }
+
+            if (vWords[1] == "JOIN" && vWords[0].size() > 1)
+            {
+                // :username!username@50000007.F000000B.90000002.IP JOIN :#channelname
+                strcpy(pszName, vWords[0].c_str() + 1);
+                if (strchr(pszName, '!'))
+                    *strchr(pszName, '!') = '\0';
+                printf("GOT JOIN: [%s]  ", pszName);
+            }
+
+            if (pszName[0] == 'u')
+            {
+                CAddress addr;
+                if (DecodeAddress(pszName, addr))
+                {
+                    CAddrDB addrdb;
+                    if (AddAddress(addrdb, addr))
+                        printf("new  ");
+                    else
+                    {
+                        // make it try connecting again
+                        CRITICAL_BLOCK(cs_mapAddresses)
+                            if (mapAddresses.count(addr.GetKey()))
+                                mapAddresses[addr.GetKey()].nLastFailed = 0;
+                    }
+                    addr.print();
+
+                    CRITICAL_BLOCK(cs_mapIRCAddresses)
+                        mapIRCAddresses.insert(make_pair(addr.GetKey(), addr));
+                }
+                else
+                {
+                    printf("decode failed\n");
+                }
+            }
+        }
+        closesocket(hSocket);
+
+        if (GetTime() - nStart > 20 * 60)
+        {
+            nErrorWait /= 3;
+            nRetryWait /= 3;
+        }
+
+        nRetryWait = nRetryWait * 11 / 10;
+        if (!Wait(nRetryWait += 60))
+            return;
+    }
+}
+
+
+
+
+
+
+
+
+
+
+#ifdef TEST
+int main(int argc, char *argv[])
+{
+    WSADATA wsadata;
+    if (WSAStartup(MAKEWORD(2,2), &wsadata) != NO_ERROR)
+    {
+        printf("Error at WSAStartup()\n");
+        return false;
+    }
+
+    ThreadIRCSeed(NULL);
+
+    WSACleanup();
+    return 0;
+}
+#endif
/trunk/irc.h Diff Switch to side-by-side view
--- a
+++ b/trunk/irc.h
@@ -0,0 +1,10 @@
+// Copyright (c) 2009 Satoshi Nakamoto
+// Distributed under the MIT/X11 software license, see the accompanying
+// file license.txt or http://www.opensource.org/licenses/mit-license.php.
+
+extern bool RecvLine(SOCKET hSocket, string& strLine);
+extern void ThreadIRCSeed(void* parg);
+extern bool fRestartIRCSeed;
+
+extern map<vector<unsigned char>, CAddress> mapIRCAddresses;
+extern CCriticalSection cs_mapIRCAddresses;
/trunk/key.h Diff Switch to side-by-side view
--- a
+++ b/trunk/key.h
@@ -0,0 +1,156 @@
+// Copyright (c) 2009 Satoshi Nakamoto
+// Distributed under the MIT/X11 software license, see the accompanying
+// file license.txt or http://www.opensource.org/licenses/mit-license.php.
+
+
+// secp160k1
+// const unsigned int PRIVATE_KEY_SIZE = 192;
+// const unsigned int PUBLIC_KEY_SIZE  = 41;
+// const unsigned int SIGNATURE_SIZE   = 48;
+//
+// secp192k1
+// const unsigned int PRIVATE_KEY_SIZE = 222;
+// const unsigned int PUBLIC_KEY_SIZE  = 49;
+// const unsigned int SIGNATURE_SIZE   = 57;
+//
+// secp224k1
+// const unsigned int PRIVATE_KEY_SIZE = 250;
+// const unsigned int PUBLIC_KEY_SIZE  = 57;
+// const unsigned int SIGNATURE_SIZE   = 66;
+//
+// secp256k1:
+// const unsigned int PRIVATE_KEY_SIZE = 279;
+// const unsigned int PUBLIC_KEY_SIZE  = 65;
+// const unsigned int SIGNATURE_SIZE   = 72;
+//
+// see www.keylength.com
+// script supports up to 75 for single byte push
+
+
+
+class key_error : public std::runtime_error
+{
+public:
+    explicit key_error(const std::string& str) : std::runtime_error(str) {}
+};
+
+
+// secure_allocator is defined is serialize.h
+typedef vector<unsigned char, secure_allocator<unsigned char> > CPrivKey;
+
+
+
+class CKey
+{
+protected:
+    EC_KEY* pkey;
+
+public:
+    CKey()
+    {
+        pkey = EC_KEY_new_by_curve_name(NID_secp256k1);
+        if (pkey == NULL)
+            throw key_error("CKey::CKey() : EC_KEY_new_by_curve_name failed");
+    }
+
+    CKey(const CKey& b)
+    {
+        pkey = EC_KEY_dup(b.pkey);
+        if (pkey == NULL)
+            throw key_error("CKey::CKey(const CKey&) : EC_KEY_dup failed");
+    }
+
+    CKey& operator=(const CKey& b)
+    {
+        if (!EC_KEY_copy(pkey, b.pkey))
+            throw key_error("CKey::operator=(const CKey&) : EC_KEY_copy failed");
+        return (*this);
+    }
+
+    ~CKey()
+    {
+        EC_KEY_free(pkey);
+    }
+
+    void MakeNewKey()
+    {
+        if (!EC_KEY_generate_key(pkey))
+            throw key_error("CKey::MakeNewKey() : EC_KEY_generate_key failed");
+    }
+
+    bool SetPrivKey(const CPrivKey& vchPrivKey)
+    {
+        const unsigned char* pbegin = &vchPrivKey[0];
+        if (!d2i_ECPrivateKey(&pkey, &pbegin, vchPrivKey.size()))
+            return false;
+        return true;
+    }
+
+    CPrivKey GetPrivKey() const
+    {
+        unsigned int nSize = i2d_ECPrivateKey(pkey, NULL);
+        if (!nSize)
+            throw key_error("CKey::GetPrivKey() : i2d_ECPrivateKey failed");
+        CPrivKey vchPrivKey(nSize, 0);
+        unsigned char* pbegin = &vchPrivKey[0];
+        if (i2d_ECPrivateKey(pkey, &pbegin) != nSize)
+            throw key_error("CKey::GetPrivKey() : i2d_ECPrivateKey returned unexpected size");
+        return vchPrivKey;
+    }
+
+    bool SetPubKey(const vector<unsigned char>& vchPubKey)
+    {
+        const unsigned char* pbegin = &vchPubKey[0];
+        if (!o2i_ECPublicKey(&pkey, &pbegin, vchPubKey.size()))
+            return false;
+        return true;
+    }
+
+    vector<unsigned char> GetPubKey() const
+    {
+        unsigned int nSize = i2o_ECPublicKey(pkey, NULL);
+        if (!nSize)
+            throw key_error("CKey::GetPubKey() : i2o_ECPublicKey failed");
+        vector<unsigned char> vchPubKey(nSize, 0);
+        unsigned char* pbegin = &vchPubKey[0];
+        if (i2o_ECPublicKey(pkey, &pbegin) != nSize)
+            throw key_error("CKey::GetPubKey() : i2o_ECPublicKey returned unexpected size");
+        return vchPubKey;
+    }
+
+    bool Sign(uint256 hash, vector<unsigned char>& vchSig)
+    {
+        vchSig.clear();
+        unsigned char pchSig[10000];
+        unsigned int nSize = 0;
+        if (!ECDSA_sign(0, (unsigned char*)&hash, sizeof(hash), pchSig, &nSize, pkey))
+            return false;
+        vchSig.resize(nSize);
+        memcpy(&vchSig[0], pchSig, nSize);
+        return true;
+    }
+
+    bool Verify(uint256 hash, const vector<unsigned char>& vchSig)
+    {
+        // -1 = error, 0 = bad sig, 1 = good
+        if (ECDSA_verify(0, (unsigned char*)&hash, sizeof(hash), &vchSig[0], vchSig.size(), pkey) != 1)
+            return false;
+        return true;
+    }
+
+    static bool Sign(const CPrivKey& vchPrivKey, uint256 hash, vector<unsigned char>& vchSig)
+    {
+        CKey key;
+        if (!key.SetPrivKey(vchPrivKey))
+            return false;
+        return key.Sign(hash, vchSig);
+    }
+
+    static bool Verify(const vector<unsigned char>& vchPubKey, uint256 hash, const vector<unsigned char>& vchSig)
+    {
+        CKey key;
+        if (!key.SetPubKey(vchPubKey))
+            return false;
+        return key.Verify(hash, vchSig);
+    }
+};
/trunk/libeay32.dll
Binary file was added.
/trunk/license.txt Diff Switch to side-by-side view
--- a
+++ b/trunk/license.txt
@@ -0,0 +1,19 @@
+Copyright (c) 2009 Satoshi Nakamoto
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
/trunk/main.cpp Diff Switch to side-by-side view
--- a
+++ b/trunk/main.cpp
@@ -0,0 +1,2692 @@
+// Copyright (c) 2009 Satoshi Nakamoto
+// Distributed under the MIT/X11 software license, see the accompanying
+// file license.txt or http://www.opensource.org/licenses/mit-license.php.
+
+#include "headers.h"
+#include "sha.h"
+
+
+
+
+
+//
+// Global state
+//
+
+CCriticalSection cs_main;
+
+map<uint256, CTransaction> mapTransactions;
+CCriticalSection cs_mapTransactions;
+unsigned int nTransactionsUpdated = 0;
+map<COutPoint, CInPoint> mapNextTx;
+
+map<uint256, CBlockIndex*> mapBlockIndex;
+const uint256 hashGenesisBlock("0x000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f");
+CBlockIndex* pindexGenesisBlock = NULL;
+int nBestHeight = -1;
+uint256 hashBestChain = 0;
+CBlockIndex* pindexBest = NULL;
+
+map<uint256, CBlock*> mapOrphanBlocks;
+multimap<uint256, CBlock*> mapOrphanBlocksByPrev;
+
+map<uint256, CDataStream*> mapOrphanTransactions;
+multimap<uint256, CDataStream*> mapOrphanTransactionsByPrev;
+
+map<uint256, CWalletTx> mapWallet;
+vector<pair<uint256, bool> > vWalletUpdated;
+CCriticalSection cs_mapWallet;
+
+map<vector<unsigned char>, CPrivKey> mapKeys;
+map<uint160, vector<unsigned char> > mapPubKeys;
+CCriticalSection cs_mapKeys;
+CKey keyUser;
+
+string strSetDataDir;
+int nDropMessagesTest = 0;
+
+// Settings
+int fGenerateBitcoins;
+int64 nTransactionFee = 0;
+CAddress addrIncoming;
+
+
+
+
+
+
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// mapKeys
+//
+
+bool AddKey(const CKey& key)
+{
+    CRITICAL_BLOCK(cs_mapKeys)
+    {
+        mapKeys[key.GetPubKey()] = key.GetPrivKey();
+        mapPubKeys[Hash160(key.GetPubKey())] = key.GetPubKey();
+    }
+    return CWalletDB().WriteKey(key.GetPubKey(), key.GetPrivKey());
+}
+
+vector<unsigned char> GenerateNewKey()
+{
+    CKey key;
+    key.MakeNewKey();
+    if (!AddKey(key))
+        throw runtime_error("GenerateNewKey() : AddKey failed\n");
+    return key.GetPubKey();
+}
+
+
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// mapWallet
+//
+
+bool AddToWallet(const CWalletTx& wtxIn)
+{
+    uint256 hash = wtxIn.GetHash();
+    CRITICAL_BLOCK(cs_mapWallet)
+    {
+        // Inserts only if not already there, returns tx inserted or tx found
+        pair<map<uint256, CWalletTx>::iterator, bool> ret = mapWallet.insert(make_pair(hash, wtxIn));
+        CWalletTx& wtx = (*ret.first).second;
+        bool fInsertedNew = ret.second;
+        if (fInsertedNew)
+            wtx.nTimeReceived = GetAdjustedTime();
+
+        //// debug print
+        printf("AddToWallet %s  %s\n", wtxIn.GetHash().ToString().substr(0,6).c_str(), fInsertedNew ? "new" : "update");
+
+        if (!fInsertedNew)
+        {
+            // Merge
+            bool fUpdated = false;
+            if (wtxIn.hashBlock != 0 && wtxIn.hashBlock != wtx.hashBlock)
+            {
+                wtx.hashBlock = wtxIn.hashBlock;
+                fUpdated = true;
+            }
+            if (wtxIn.nIndex != -1 && (wtxIn.vMerkleBranch != wtx.vMerkleBranch || wtxIn.nIndex != wtx.nIndex))
+            {
+                wtx.vMerkleBranch = wtxIn.vMerkleBranch;
+                wtx.nIndex = wtxIn.nIndex;
+                fUpdated = true;
+            }
+            if (wtxIn.fFromMe && wtxIn.fFromMe != wtx.fFromMe)
+            {
+                wtx.fFromMe = wtxIn.fFromMe;
+                fUpdated = true;
+            }
+            if (wtxIn.fSpent && wtxIn.fSpent != wtx.fSpent)
+            {
+                wtx.fSpent = wtxIn.fSpent;
+                fUpdated = true;
+            }
+            if (!fUpdated)
+                return true;
+        }
+
+        // Write to disk
+        if (!wtx.WriteToDisk())
+            return false;
+
+        // Notify UI
+        vWalletUpdated.push_back(make_pair(hash, fInsertedNew));
+    }
+
+    // Refresh UI
+    MainFrameRepaint();
+    return true;
+}
+
+bool AddToWalletIfMine(const CTransaction& tx, const CBlock* pblock)
+{
+    if (tx.IsMine() || mapWallet.count(tx.GetHash()))
+    {
+        CWalletTx wtx(tx);
+        // Get merkle branch if transaction was found in a block
+        if (pblock)
+            wtx.SetMerkleBranch(pblock);
+        return AddToWallet(wtx);
+    }
+    return true;
+}
+
+bool EraseFromWallet(uint256 hash)
+{
+    CRITICAL_BLOCK(cs_mapWallet)
+    {
+        if (mapWallet.erase(hash))
+            CWalletDB().EraseTx(hash);
+    }
+    return true;
+}
+
+
+
+
+
+
+
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// mapOrphanTransactions
+//
+
+void AddOrphanTx(const CDataStream& vMsg)
+{
+    CTransaction tx;
+    CDataStream(vMsg) >> tx;
+    uint256 hash = tx.GetHash();
+    if (mapOrphanTransactions.count(hash))
+        return;
+    CDataStream* pvMsg = mapOrphanTransactions[hash] = new CDataStream(vMsg);
+    foreach(const CTxIn& txin, tx.vin)
+        mapOrphanTransactionsByPrev.insert(make_pair(txin.prevout.hash, pvMsg));
+}
+
+void EraseOrphanTx(uint256 hash)
+{
+    if (!mapOrphanTransactions.count(hash))
+        return;
+    const CDataStream* pvMsg = mapOrphanTransactions[hash];
+    CTransaction tx;
+    CDataStream(*pvMsg) >> tx;
+    foreach(const CTxIn& txin, tx.vin)
+    {
+        for (multimap<uint256, CDataStream*>::iterator mi = mapOrphanTransactionsByPrev.lower_bound(txin.prevout.hash);
+             mi != mapOrphanTransactionsByPrev.upper_bound(txin.prevout.hash);)
+        {
+            if ((*mi).second == pvMsg)
+                mapOrphanTransactionsByPrev.erase(mi++);
+            else
+                mi++;
+        }
+    }
+    delete pvMsg;
+    mapOrphanTransactions.erase(hash);
+}
+
+
+
+
+
+
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// CTransaction
+//
+
+bool CTxIn::IsMine() const
+{
+    CRITICAL_BLOCK(cs_mapWallet)
+    {
+        map<uint256, CWalletTx>::iterator mi = mapWallet.find(prevout.hash);
+        if (mi != mapWallet.end())
+        {
+            const CWalletTx& prev = (*mi).second;
+            if (prevout.n < prev.vout.size())
+                if (prev.vout[prevout.n].IsMine())
+                    return true;
+        }
+    }
+    return false;
+}
+
+int64 CTxIn::GetDebit() const
+{
+    CRITICAL_BLOCK(cs_mapWallet)
+    {
+        map<uint256, CWalletTx>::iterator mi = mapWallet.find(prevout.hash);
+        if (mi != mapWallet.end())
+        {
+            const CWalletTx& prev = (*mi).second;
+            if (prevout.n < prev.vout.size())
+                if (prev.vout[prevout.n].IsMine())
+                    return prev.vout[prevout.n].nValue;
+        }
+    }
+    return 0;
+}
+
+int64 CWalletTx::GetTxTime() const
+{
+    if (!fTimeReceivedIsTxTime && hashBlock != 0)
+    {
+        // If we did not receive the transaction directly, we rely on the block's
+        // time to figure out when it happened.  We use the median over a range
+        // of blocks to try to filter out inaccurate block times.
+        map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);
+        if (mi != mapBlockIndex.end())
+        {
+            CBlockIndex* pindex = (*mi).second;
+            if (pindex)
+                return pindex->GetMedianTime();
+        }
+    }
+    return nTimeReceived;
+}
+
+
+
+
+
+
+int CMerkleTx::SetMerkleBranch(const CBlock* pblock)
+{
+    if (fClient)
+    {
+        if (hashBlock == 0)
+            return 0;
+    }
+    else
+    {
+        CBlock blockTmp;
+        if (pblock == NULL)
+        {
+            // Load the block this tx is in
+            CTxIndex txindex;
+            if (!CTxDB("r").ReadTxIndex(GetHash(), txindex))
+                return 0;
+            if (!blockTmp.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, true))
+                return 0;
+            pblock = &blockTmp;
+        }
+
+        // Update the tx's hashBlock
+        hashBlock = pblock->GetHash();
+
+        // Locate the transaction
+        for (nIndex = 0; nIndex < pblock->vtx.size(); nIndex++)
+            if (pblock->vtx[nIndex] == *(CTransaction*)this)
+                break;
+        if (nIndex == pblock->vtx.size())
+        {
+            vMerkleBranch.clear();
+            nIndex = -1;
+            printf("ERROR: SetMerkleBranch() : couldn't find tx in block\n");
+            return 0;
+        }
+
+        // Fill in merkle branch
+        vMerkleBranch = pblock->GetMerkleBranch(nIndex);
+    }
+
+    // Is the tx in a block that's in the main chain
+    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);
+    if (mi == mapBlockIndex.end())
+        return 0;
+    CBlockIndex* pindex = (*mi).second;
+    if (!pindex || !pindex->IsInMainChain())
+        return 0;
+
+    return pindexBest->nHeight - pindex->nHeight + 1;
+}
+
+
+
+void CWalletTx::AddSupportingTransactions(CTxDB& txdb)
+{
+    vtxPrev.clear();
+
+    const int COPY_DEPTH = 3;
+    if (SetMerkleBranch() < COPY_DEPTH)
+    {
+        vector<uint256> vWorkQueue;
+        foreach(const CTxIn& txin, vin)
+            vWorkQueue.push_back(txin.prevout.hash);
+
+        // This critsect is OK because txdb is already open
+        CRITICAL_BLOCK(cs_mapWallet)
+        {
+            map<uint256, const CMerkleTx*> mapWalletPrev;
+            set<uint256> setAlreadyDone;
+            for (int i = 0; i < vWorkQueue.size(); i++)
+            {
+                uint256 hash = vWorkQueue[i];
+                if (setAlreadyDone.count(hash))
+                    continue;
+                setAlreadyDone.insert(hash);
+
+                CMerkleTx tx;
+                if (mapWallet.count(hash))
+                {
+                    tx = mapWallet[hash];
+                    foreach(const CMerkleTx& txWalletPrev, mapWallet[hash].vtxPrev)
+                        mapWalletPrev[txWalletPrev.GetHash()] = &txWalletPrev;
+                }
+                else if (mapWalletPrev.count(hash))
+                {
+                    tx = *mapWalletPrev[hash];
+                }
+                else if (!fClient && txdb.ReadDiskTx(hash, tx))
+                {
+                    ;
+                }
+                else
+                {
+                    printf("ERROR: AddSupportingTransactions() : unsupported transaction\n");
+                    continue;
+                }
+
+                int nDepth = tx.SetMerkleBranch();
+                vtxPrev.push_back(tx);
+
+                if (nDepth < COPY_DEPTH)
+                    foreach(const CTxIn& txin, tx.vin)
+                        vWorkQueue.push_back(txin.prevout.hash);
+            }
+        }
+    }
+
+    reverse(vtxPrev.begin(), vtxPrev.end());
+}
+
+
+
+
+
+
+
+
+
+
+
+bool CTransaction::AcceptTransaction(CTxDB& txdb, bool fCheckInputs, bool* pfMissingInputs)
+{
+    if (pfMissingInputs)
+        *pfMissingInputs = false;
+
+    // Coinbase is only valid in a block, not as a loose transaction
+    if (IsCoinBase())
+        return error("AcceptTransaction() : coinbase as individual tx");
+
+    if (!CheckTransaction())
+        return error("AcceptTransaction() : CheckTransaction failed");
+
+    // Do we already have it?
+    uint256 hash = GetHash();
+    CRITICAL_BLOCK(cs_mapTransactions)
+        if (mapTransactions.count(hash))
+            return false;
+    if (fCheckInputs)
+        if (txdb.ContainsTx(hash))
+            return false;
+
+    // Check for conflicts with in-memory transactions
+    CTransaction* ptxOld = NULL;
+    for (int i = 0; i < vin.size(); i++)
+    {
+        COutPoint outpoint = vin[i].prevout;
+        if (mapNextTx.count(outpoint))
+        {
+            // Allow replacing with a newer version of the same transaction
+            if (i != 0)
+                return false;
+            ptxOld = mapNextTx[outpoint].ptx;
+            if (!IsNewerThan(*ptxOld))
+                return false;
+            for (int i = 0; i < vin.size(); i++)
+            {
+                COutPoint outpoint = vin[i].prevout;
+                if (!mapNextTx.count(outpoint) || mapNextTx[outpoint].ptx != ptxOld)
+                    return false;
+            }
+            break;
+        }
+    }
+
+    // Check against previous transactions
+    map<uint256, CTxIndex> mapUnused;
+    int64 nFees = 0;
+    if (fCheckInputs && !ConnectInputs(txdb, mapUnused, CDiskTxPos(1,1,1), 0, nFees, false, false))
+    {
+        if (pfMissingInputs)
+            *pfMissingInputs = true;
+        return error("AcceptTransaction() : ConnectInputs failed %s", hash.ToString().substr(0,6).c_str());
+    }
+
+    // Store transaction in memory
+    CRITICAL_BLOCK(cs_mapTransactions)
+    {
+        if (ptxOld)
+        {
+            printf("mapTransaction.erase(%s) replacing with new version\n", ptxOld->GetHash().ToString().c_str());
+            mapTransactions.erase(ptxOld->GetHash());
+        }
+        AddToMemoryPool();
+    }
+
+    ///// are we sure this is ok when loading transactions or restoring block txes
+    // If updated, erase old tx from wallet
+    if (ptxOld)
+        EraseFromWallet(ptxOld->GetHash());
+
+    printf("AcceptTransaction(): accepted %s\n", hash.ToString().substr(0,6).c_str());
+    return true;
+}
+
+
+bool CTransaction::AddToMemoryPool()
+{
+    // Add to memory pool without checking anything.  Don't call this directly,
+    // call AcceptTransaction to properly check the transaction first.
+    CRITICAL_BLOCK(cs_mapTransactions)
+    {
+        uint256 hash = GetHash();
+        mapTransactions[hash] = *this;
+        for (int i = 0; i < vin.size(); i++)
+            mapNextTx[vin[i].prevout] = CInPoint(&mapTransactions[hash], i);
+        nTransactionsUpdated++;
+    }
+    return true;
+}
+
+
+bool CTransaction::RemoveFromMemoryPool()
+{
+    // Remove transaction from memory pool
+    CRITICAL_BLOCK(cs_mapTransactions)
+    {
+        foreach(const CTxIn& txin, vin)
+            mapNextTx.erase(txin.prevout);
+        mapTransactions.erase(GetHash());
+        nTransactionsUpdated++;
+    }
+    return true;
+}
+
+
+
+
+
+
+int CMerkleTx::GetDepthInMainChain() const
+{
+    if (hashBlock == 0 || nIndex == -1)
+        return 0;
+
+    // Find the block it claims to be in
+    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);
+    if (mi == mapBlockIndex.end())
+        return 0;
+    CBlockIndex* pindex = (*mi).second;
+    if (!pindex || !pindex->IsInMainChain())
+        return 0;
+
+    // Make sure the merkle branch connects to this block
+    if (!fMerkleVerified)
+    {
+        if (CBlock::CheckMerkleBranch(GetHash(), vMerkleBranch, nIndex) != pindex->hashMerkleRoot)
+            return 0;
+        fMerkleVerified = true;
+    }
+
+    return pindexBest->nHeight - pindex->nHeight + 1;
+}
+
+
+int CMerkleTx::GetBlocksToMaturity() const
+{
+    if (!IsCoinBase())
+        return 0;
+    return max(0, (COINBASE_MATURITY+20) - GetDepthInMainChain());
+}
+
+
+bool CMerkleTx::AcceptTransaction(CTxDB& txdb, bool fCheckInputs)
+{
+    if (fClient)
+    {
+        if (!IsInMainChain() && !ClientConnectInputs())
+            return false;
+        return CTransaction::AcceptTransaction(txdb, false);
+    }
+    else
+    {
+        return CTransaction::AcceptTransaction(txdb, fCheckInputs);
+    }
+}
+
+
+
+bool CWalletTx::AcceptWalletTransaction(CTxDB& txdb, bool fCheckInputs)
+{
+    CRITICAL_BLOCK(cs_mapTransactions)
+    {
+        foreach(CMerkleTx& tx, vtxPrev)
+        {
+            if (!tx.IsCoinBase())
+            {
+                uint256 hash = tx.GetHash();
+                if (!mapTransactions.count(hash) && !txdb.ContainsTx(hash))
+                    tx.AcceptTransaction(txdb, fCheckInputs);
+            }
+        }
+        if (!IsCoinBase())
+            return AcceptTransaction(txdb, fCheckInputs);
+    }
+    return true;
+}
+
+void ReacceptWalletTransactions()
+{
+    // Reaccept any txes of ours that aren't already in a block
+    CTxDB txdb("r");
+    CRITICAL_BLOCK(cs_mapWallet)
+    {
+        foreach(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)
+        {
+            CWalletTx& wtx = item.second;
+            if (!wtx.IsCoinBase() && !txdb.ContainsTx(wtx.GetHash()))
+                wtx.AcceptWalletTransaction(txdb, false);
+        }
+    }
+}
+
+
+void CWalletTx::RelayWalletTransaction(CTxDB& txdb)
+{
+    foreach(const CMerkleTx& tx, vtxPrev)
+    {
+        if (!tx.IsCoinBase())
+        {
+            uint256 hash = tx.GetHash();
+            if (!txdb.ContainsTx(hash))
+                RelayMessage(CInv(MSG_TX, hash), (CTransaction)tx);
+        }
+    }
+    if (!IsCoinBase())
+    {
+        uint256 hash = GetHash();
+        if (!txdb.ContainsTx(hash))
+        {
+            printf("Relaying wtx %s\n", hash.ToString().substr(0,6).c_str());
+            RelayMessage(CInv(MSG_TX, hash), (CTransaction)*this);
+        }
+    }
+}
+
+void RelayWalletTransactions()
+{
+    static int64 nLastTime;
+    if (GetTime() - nLastTime < 10 * 60)
+        return;
+    nLastTime = GetTime();
+
+    // Rebroadcast any of our txes that aren't in a block yet
+    printf("RelayWalletTransactions()\n");
+    CTxDB txdb("r");
+    CRITICAL_BLOCK(cs_mapWallet)
+    {
+        // Sort them in chronological order
+        multimap<unsigned int, CWalletTx*> mapSorted;
+        foreach(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)
+        {
+            CWalletTx& wtx = item.second;
+            mapSorted.insert(make_pair(wtx.nTimeReceived, &wtx));
+        }
+        foreach(PAIRTYPE(const unsigned int, CWalletTx*)& item, mapSorted)
+        {
+            CWalletTx& wtx = *item.second;
+            wtx.RelayWalletTransaction(txdb);
+        }
+    }
+}
+
+
+
+
+
+
+
+
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// CBlock and CBlockIndex
+//
+
+bool CBlock::ReadFromDisk(const CBlockIndex* pblockindex, bool fReadTransactions)
+{
+    return ReadFromDisk(pblockindex->nFile, pblockindex->nBlockPos, fReadTransactions);
+}
+
+uint256 GetOrphanRoot(const CBlock* pblock)
+{
+    // Work back to the first block in the orphan chain
+    while (mapOrphanBlocks.count(pblock->hashPrevBlock))
+        pblock = mapOrphanBlocks[pblock->hashPrevBlock];
+    return pblock->GetHash();
+}
+
+int64 CBlock::GetBlockValue(int64 nFees) const
+{
+    int64 nSubsidy = 50 * COIN;
+
+    // Subsidy is cut in half every 4 years
+    nSubsidy >>= (nBestHeight / 210000);
+
+    return nSubsidy + nFees;
+}
+
+unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast)
+{
+    const unsigned int nTargetTimespan = 14 * 24 * 60 * 60; // two weeks
+    const unsigned int nTargetSpacing = 10 * 60;
+    const unsigned int nInterval = nTargetTimespan / nTargetSpacing;
+
+    // Genesis block
+    if (pindexLast == NULL)
+        return bnProofOfWorkLimit.GetCompact();
+
+    // Only change once per interval
+    if ((pindexLast->nHeight+1) % nInterval != 0)
+        return pindexLast->nBits;
+
+    // Go back by what we want to be 14 days worth of blocks
+    const CBlockIndex* pindexFirst = pindexLast;
+    for (int i = 0; pindexFirst && i < nInterval-1; i++)
+        pindexFirst = pindexFirst->pprev;
+    assert(pindexFirst);
+
+    // Limit adjustment step
+    unsigned int nActualTimespan = pindexLast->nTime - pindexFirst->nTime;
+    printf("  nActualTimespan = %d  before bounds\n", nActualTimespan);
+    if (nActualTimespan < nTargetTimespan/4)
+        nActualTimespan = nTargetTimespan/4;
+    if (nActualTimespan > nTargetTimespan*4)
+        nActualTimespan = nTargetTimespan*4;
+
+    // Retarget
+    CBigNum bnNew;
+    bnNew.SetCompact(pindexLast->nBits);
+    bnNew *= nActualTimespan;
+    bnNew /= nTargetTimespan;
+
+    if (bnNew > bnProofOfWorkLimit)
+        bnNew = bnProofOfWorkLimit;
+
+    /// debug print
+    printf("\n\n\nGetNextWorkRequired RETARGET *****\n");
+    printf("nTargetTimespan = %d    nActualTimespan = %d\n", nTargetTimespan, nActualTimespan);
+    printf("Before: %08x  %s\n", pindexLast->nBits, CBigNum().SetCompact(pindexLast->nBits).getuint256().ToString().c_str());
+    printf("After:  %08x  %s\n", bnNew.GetCompact(), bnNew.getuint256().ToString().c_str());
+
+    return bnNew.GetCompact();
+}
+
+
+
+
+
+
+
+
+
+bool CTransaction::DisconnectInputs(CTxDB& txdb)
+{
+    // Relinquish previous transactions' spent pointers
+    if (!IsCoinBase())
+    {
+        foreach(const CTxIn& txin, vin)
+        {
+            COutPoint prevout = txin.prevout;
+
+            // Get prev txindex from disk
+            CTxIndex txindex;
+            if (!txdb.ReadTxIndex(prevout.hash, txindex))
+                return error("DisconnectInputs() : ReadTxIndex failed");
+
+            if (prevout.n >= txindex.vSpent.size())
+                return error("DisconnectInputs() : prevout.n out of range");
+
+            // Mark outpoint as not spent
+            txindex.vSpent[prevout.n].SetNull();
+
+            // Write back
+            txdb.UpdateTxIndex(prevout.hash, txindex);
+        }
+    }
+
+    // Remove transaction from index
+    if (!txdb.EraseTxIndex(*this))
+        return error("DisconnectInputs() : EraseTxPos failed");
+
+    return true;
+}
+
+
+bool CTransaction::ConnectInputs(CTxDB& txdb, map<uint256, CTxIndex>& mapTestPool, CDiskTxPos posThisTx, int nHeight, int64& nFees, bool fBlock, bool fMiner, int64 nMinFee)
+{
+    // Take over previous transactions' spent pointers
+    if (!IsCoinBase())
+    {
+        int64 nValueIn = 0;
+        for (int i = 0; i < vin.size(); i++)
+        {
+            COutPoint prevout = vin[i].prevout;
+
+            // Read txindex
+            CTxIndex txindex;
+            bool fFound = true;
+            if (fMiner && mapTestPool.count(prevout.hash))
+            {
+                // Get txindex from current proposed changes
+                txindex = mapTestPool[prevout.hash];
+            }
+            else
+            {
+                // Read txindex from txdb
+                fFound = txdb.ReadTxIndex(prevout.hash, txindex);
+            }
+            if (!fFound && (fBlock || fMiner))
+                return fMiner ? false : error("ConnectInputs() : %s prev tx %s index entry not found", GetHash().ToString().substr(0,6).c_str(),  prevout.hash.ToString().substr(0,6).c_str());
+
+            // Read txPrev
+            CTransaction txPrev;
+            if (!fFound || txindex.pos == CDiskTxPos(1,1,1))
+            {
+                // Get prev tx from single transactions in memory
+                CRITICAL_BLOCK(cs_mapTransactions)
+                {
+                    if (!mapTransactions.count(prevout.hash))
+                        return error("ConnectInputs() : %s mapTransactions prev not found %s", GetHash().ToString().substr(0,6).c_str(),  prevout.hash.ToString().substr(0,6).c_str());
+                    txPrev = mapTransactions[prevout.hash];
+                }
+                if (!fFound)
+                    txindex.vSpent.resize(txPrev.vout.size());
+            }
+            else
+            {
+                // Get prev tx from disk
+                if (!txPrev.ReadFromDisk(txindex.pos))
+                    return error("ConnectInputs() : %s ReadFromDisk prev tx %s failed", GetHash().ToString().substr(0,6).c_str(),  prevout.hash.ToString().substr(0,6).c_str());
+            }
+
+            if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())
+                return error("ConnectInputs() : %s prevout.n out of range %d %d %d", GetHash().ToString().substr(0,6).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size());
+
+            // If prev is coinbase, check that it's matured
+            if (txPrev.IsCoinBase())
+                for (CBlockIndex* pindex = pindexBest; pindex && nBestHeight - pindex->nHeight < COINBASE_MATURITY-1; pindex = pindex->pprev)
+                    if (pindex->nBlockPos == txindex.pos.nBlockPos && pindex->nFile == txindex.pos.nFile)
+                        return error("ConnectInputs() : tried to spend coinbase at depth %d", nBestHeight - pindex->nHeight);
+
+            // Verify signature
+            if (!VerifySignature(txPrev, *this, i))
+                return error("ConnectInputs() : %s VerifySignature failed", GetHash().ToString().substr(0,6).c_str());
+
+            // Check for conflicts
+            if (!txindex.vSpent[prevout.n].IsNull())
+                return fMiner ? false : error("ConnectInputs() : %s prev tx already used at %s", GetHash().ToString().substr(0,6).c_str(), txindex.vSpent[prevout.n].ToString().c_str());
+
+            // Mark outpoints as spent
+            txindex.vSpent[prevout.n] = posThisTx;
+
+            // Write back
+            if (fBlock)
+                txdb.UpdateTxIndex(prevout.hash, txindex);
+            else if (fMiner)
+                mapTestPool[prevout.hash] = txindex;
+
+            nValueIn += txPrev.vout[prevout.n].nValue;
+        }
+
+        // Tally transaction fees
+        int64 nTxFee = nValueIn - GetValueOut();
+        if (nTxFee < 0)
+            return error("ConnectInputs() : %s nTxFee < 0", GetHash().ToString().substr(0,6).c_str());
+        if (nTxFee < nMinFee)
+            return false;
+        nFees += nTxFee;
+    }
+
+    if (fBlock)
+    {
+        // Add transaction to disk index
+        if (!txdb.AddTxIndex(*this, posThisTx, nHeight))
+            return error("ConnectInputs() : AddTxPos failed");
+    }
+    else if (fMiner)
+    {
+        // Add transaction to test pool
+        mapTestPool[GetHash()] = CTxIndex(CDiskTxPos(1,1,1), vout.size());
+    }
+
+    return true;
+}
+
+
+bool CTransaction::ClientConnectInputs()
+{
+    if (IsCoinBase())
+        return false;
+
+    // Take over previous transactions' spent pointers
+    CRITICAL_BLOCK(cs_mapTransactions)
+    {
+        int64 nValueIn = 0;
+        for (int i = 0; i < vin.size(); i++)
+        {
+            // Get prev tx from single transactions in memory
+            COutPoint prevout = vin[i].prevout;
+            if (!mapTransactions.count(prevout.hash))
+                return false;
+            CTransaction& txPrev = mapTransactions[prevout.hash];
+
+            if (prevout.n >= txPrev.vout.size())
+                return false;
+
+            // Verify signature
+            if (!VerifySignature(txPrev, *this, i))
+                return error("ConnectInputs() : VerifySignature failed");
+
+            ///// this is redundant with the mapNextTx stuff, not sure which I want to get rid of
+            ///// this has to go away now that posNext is gone
+            // // Check for conflicts
+            // if (!txPrev.vout[prevout.n].posNext.IsNull())
+            //     return error("ConnectInputs() : prev tx already used");
+            //
+            // // Flag outpoints as used
+            // txPrev.vout[prevout.n].posNext = posThisTx;
+
+            nValueIn += txPrev.vout[prevout.n].nValue;
+        }
+        if (GetValueOut() > nValueIn)
+            return false;
+    }
+
+    return true;
+}
+
+
+
+
+bool CBlock::DisconnectBlock(CTxDB& txdb, CBlockIndex* pindex)
+{
+    // Disconnect in reverse order
+    for (int i = vtx.size()-1; i >= 0; i--)
+        if (!vtx[i].DisconnectInputs(txdb))
+            return false;
+
+    // Update block index on disk without changing it in memory.
+    // The memory index structure will be changed after the db commits.
+    if (pindex->pprev)
+    {
+        CDiskBlockIndex blockindexPrev(pindex->pprev);
+        blockindexPrev.hashNext = 0;
+        txdb.WriteBlockIndex(blockindexPrev);
+    }
+
+    return true;
+}
+
+bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex)
+{
+    //// issue here: it doesn't know the version
+    unsigned int nTxPos = pindex->nBlockPos + ::GetSerializeSize(CBlock(), SER_DISK) - 1 + GetSizeOfCompactSize(vtx.size());
+
+    map<uint256, CTxIndex> mapUnused;
+    int64 nFees = 0;
+    foreach(CTransaction& tx, vtx)
+    {
+        CDiskTxPos posThisTx(pindex->nFile, pindex->nBlockPos, nTxPos);
+        nTxPos += ::GetSerializeSize(tx, SER_DISK);
+
+        if (!tx.ConnectInputs(txdb, mapUnused, posThisTx, pindex->nHeight, nFees, true, false))
+            return false;
+    }
+
+    if (vtx[0].GetValueOut() > GetBlockValue(nFees))
+        return false;
+
+    // Update block index on disk without changing it in memory.
+    // The memory index structure will be changed after the db commits.
+    if (pindex->pprev)
+    {
+        CDiskBlockIndex blockindexPrev(pindex->pprev);
+        blockindexPrev.hashNext = pindex->GetBlockHash();
+        txdb.WriteBlockIndex(blockindexPrev);
+    }
+
+    // Watch for transactions paying to me
+    foreach(CTransaction& tx, vtx)
+        AddToWalletIfMine(tx, this);
+
+    return true;
+}
+
+
+
+bool Reorganize(CTxDB& txdb, CBlockIndex* pindexNew)
+{
+    printf("*** REORGANIZE ***\n");
+
+    // Find the fork
+    CBlockIndex* pfork = pindexBest;
+    CBlockIndex* plonger = pindexNew;
+    while (pfork != plonger)
+    {
+        if (!(pfork = pfork->pprev))
+            return error("Reorganize() : pfork->pprev is null");
+        while (plonger->nHeight > pfork->nHeight)
+            if (!(plonger = plonger->pprev))
+                return error("Reorganize() : plonger->pprev is null");
+    }
+
+    // List of what to disconnect
+    vector<CBlockIndex*> vDisconnect;
+    for (CBlockIndex* pindex = pindexBest; pindex != pfork; pindex = pindex->pprev)
+        vDisconnect.push_back(pindex);
+
+    // List of what to connect
+    vector<CBlockIndex*> vConnect;
+    for (CBlockIndex* pindex = pindexNew; pindex != pfork; pindex = pindex->pprev)
+        vConnect.push_back(pindex);
+    reverse(vConnect.begin(), vConnect.end());
+
+    // Disconnect shorter branch
+    vector<CTransaction> vResurrect;
+    foreach(CBlockIndex* pindex, vDisconnect)
+    {
+        CBlock block;
+        if (!block.ReadFromDisk(pindex->nFile, pindex->nBlockPos, true))
+            return error("Reorganize() : ReadFromDisk for disconnect failed");
+        if (!block.DisconnectBlock(txdb, pindex))
+            return error("Reorganize() : DisconnectBlock failed");
+
+        // Queue memory transactions to resurrect
+        foreach(const CTransaction& tx, block.vtx)
+            if (!tx.IsCoinBase())
+                vResurrect.push_back(tx);
+    }
+
+    // Connect longer branch
+    vector<CTransaction> vDelete;
+    for (int i = 0; i < vConnect.size(); i++)
+    {
+        CBlockIndex* pindex = vConnect[i];
+        CBlock block;
+        if (!block.ReadFromDisk(pindex->nFile, pindex->nBlockPos, true))
+            return error("Reorganize() : ReadFromDisk for connect failed");
+        if (!block.ConnectBlock(txdb, pindex))
+        {
+            // Invalid block, delete the rest of this branch
+            txdb.TxnAbort();
+            for (int j = i; j < vConnect.size(); j++)
+            {
+                CBlockIndex* pindex = vConnect[j];
+                pindex->EraseBlockFromDisk();
+                txdb.EraseBlockIndex(pindex->GetBlockHash());
+                mapBlockIndex.erase(pindex->GetBlockHash());
+                delete pindex;
+            }
+            return error("Reorganize() : ConnectBlock failed");
+        }
+
+        // Queue memory transactions to delete
+        foreach(const CTransaction& tx, block.vtx)
+            vDelete.push_back(tx);
+    }
+    if (!txdb.WriteHashBestChain(pindexNew->GetBlockHash()))
+        return error("Reorganize() : WriteHashBestChain failed");
+
+    // Commit now because resurrecting could take some time
+    txdb.TxnCommit();
+
+    // Disconnect shorter branch
+    foreach(CBlockIndex* pindex, vDisconnect)
+        if (pindex->pprev)
+            pindex->pprev->pnext = NULL;
+
+    // Connect longer branch
+    foreach(CBlockIndex* pindex, vConnect)
+        if (pindex->pprev)
+            pindex->pprev->pnext = pindex;
+
+    // Resurrect memory transactions that were in the disconnected branch
+    foreach(CTransaction& tx, vResurrect)
+        tx.AcceptTransaction(txdb, false);
+
+    // Delete redundant memory transactions that are in the connected branch
+    foreach(CTransaction& tx, vDelete)
+        tx.RemoveFromMemoryPool();
+
+    return true;
+}
+
+
+bool CBlock::AddToBlockIndex(unsigned int nFile, unsigned int nBlockPos)
+{
+    // Check for duplicate
+    uint256 hash = GetHash();
+    if (mapBlockIndex.count(hash))
+        return error("AddToBlockIndex() : %s already exists", hash.ToString().substr(0,14).c_str());
+
+    // Construct new block index object
+    CBlockIndex* pindexNew = new CBlockIndex(nFile, nBlockPos, *this);
+    if (!pindexNew)
+        return error("AddToBlockIndex() : new CBlockIndex failed");
+    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;
+    pindexNew->phashBlock = &((*mi).first);
+    map<uint256, CBlockIndex*>::iterator miPrev = mapBlockIndex.find(hashPrevBlock);
+    if (miPrev != mapBlockIndex.end())
+    {
+        pindexNew->pprev = (*miPrev).second;
+        pindexNew->nHeight = pindexNew->pprev->nHeight + 1;
+    }
+
+    CTxDB txdb;
+    txdb.TxnBegin();
+    txdb.WriteBlockIndex(CDiskBlockIndex(pindexNew));
+
+    // New best
+    if (pindexNew->nHeight > nBestHeight)
+    {
+        if (pindexGenesisBlock == NULL && hash == hashGenesisBlock)
+        {
+            pindexGenesisBlock = pindexNew;
+            txdb.WriteHashBestChain(hash);
+        }
+        else if (hashPrevBlock == hashBestChain)
+        {
+            // Adding to current best branch
+            if (!ConnectBlock(txdb, pindexNew) || !txdb.WriteHashBestChain(hash))
+            {
+                txdb.TxnAbort();
+                pindexNew->EraseBlockFromDisk();
+                mapBlockIndex.erase(pindexNew->GetBlockHash());
+                delete pindexNew;
+                return error("AddToBlockIndex() : ConnectBlock failed");
+            }
+            txdb.TxnCommit();
+            pindexNew->pprev->pnext = pindexNew;
+
+            // Delete redundant memory transactions
+            foreach(CTransaction& tx, vtx)
+                tx.RemoveFromMemoryPool();
+        }
+        else
+        {
+            // New best branch
+            if (!Reorganize(txdb, pindexNew))
+            {
+                txdb.TxnAbort();
+                return error("AddToBlockIndex() : Reorganize failed");
+            }
+        }
+
+        // New best link
+        hashBestChain = hash;
+        pindexBest = pindexNew;
+        nBestHeight = pindexBest->nHeight;
+        nTransactionsUpdated++;
+        printf("AddToBlockIndex: new best=%s  height=%d\n", hashBestChain.ToString().substr(0,14).c_str(), nBestHeight);
+    }
+
+    txdb.TxnCommit();
+    txdb.Close();
+
+    // Relay wallet transactions that haven't gotten in yet
+    if (pindexNew == pindexBest)
+        RelayWalletTransactions();
+
+    MainFrameRepaint();
+    return true;
+}
+
+
+
+
+bool CBlock::CheckBlock() const
+{
+    // These are checks that are independent of context
+    // that can be verified before saving an orphan block.
+
+    // Size limits
+    if (vtx.empty() || vtx.size() > MAX_SIZE || ::GetSerializeSize(*this, SER_DISK) > MAX_SIZE)
+        return error("CheckBlock() : size limits failed");
+
+    // Check timestamp
+    if (nTime > GetAdjustedTime() + 2 * 60 * 60)
+        return error("CheckBlock() : block timestamp too far in the future");
+
+    // First transaction must be coinbase, the rest must not be
+    if (vtx.empty() || !vtx[0].IsCoinBase())
+        return error("CheckBlock() : first tx is not coinbase");
+    for (int i = 1; i < vtx.size(); i++)
+        if (vtx[i].IsCoinBase())
+            return error("CheckBlock() : more than one coinbase");
+
+    // Check transactions
+    foreach(const CTransaction& tx, vtx)
+        if (!tx.CheckTransaction())
+            return error("CheckBlock() : CheckTransaction failed");
+
+    // Check proof of work matches claimed amount
+    if (CBigNum().SetCompact(nBits) > bnProofOfWorkLimit)
+        return error("CheckBlock() : nBits below minimum work");
+    if (GetHash() > CBigNum().SetCompact(nBits).getuint256())
+        return error("CheckBlock() : hash doesn't match nBits");
+
+    // Check merkleroot
+    if (hashMerkleRoot != BuildMerkleTree())
+        return error("CheckBlock() : hashMerkleRoot mismatch");
+
+    return true;
+}
+
+bool CBlock::AcceptBlock()
+{
+    // Check for duplicate
+    uint256 hash = GetHash();
+    if (mapBlockIndex.count(hash))
+        return error("AcceptBlock() : block already in mapBlockIndex");
+
+    // Get prev block index
+    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashPrevBlock);
+    if (mi == mapBlockIndex.end())
+        return error("AcceptBlock() : prev block not found");
+    CBlockIndex* pindexPrev = (*mi).second;
+
+    // Check timestamp against prev
+    if (nTime <= pindexPrev->GetMedianTimePast())
+        return error("AcceptBlock() : block's timestamp is too early");
+
+    // Check proof of work
+    if (nBits != GetNextWorkRequired(pindexPrev))
+        return error("AcceptBlock() : incorrect proof of work");
+
+    // Write block to history file
+    if (!CheckDiskSpace(::GetSerializeSize(*this, SER_DISK)))
+        return error("AcceptBlock() : out of disk space");
+    unsigned int nFile;
+    unsigned int nBlockPos;
+    if (!WriteToDisk(!fClient, nFile, nBlockPos))
+        return error("AcceptBlock() : WriteToDisk failed");
+    if (!AddToBlockIndex(nFile, nBlockPos))
+        return error("AcceptBlock() : AddToBlockIndex failed");
+
+    if (hashBestChain == hash)
+        RelayInventory(CInv(MSG_BLOCK, hash));
+
+    // // Add atoms to user reviews for coins created
+    // vector<unsigned char> vchPubKey;
+    // if (ExtractPubKey(vtx[0].vout[0].scriptPubKey, false, vchPubKey))
+    // {
+    //     unsigned short nAtom = GetRand(USHRT_MAX - 100) + 100;
+    //     vector<unsigned short> vAtoms(1, nAtom);
+    //     AddAtomsAndPropagate(Hash(vchPubKey.begin(), vchPubKey.end()), vAtoms, true);
+    // }
+
+    return true;
+}
+
+bool ProcessBlock(CNode* pfrom, CBlock* pblock)
+{
+    // Check for duplicate
+    uint256 hash = pblock->GetHash();
+    if (mapBlockIndex.count(hash))
+        return error("ProcessBlock() : already have block %d %s", mapBlockIndex[hash]->nHeight, hash.ToString().substr(0,14).c_str());
+    if (mapOrphanBlocks.count(hash))
+        return error("ProcessBlock() : already have block (orphan) %s", hash.ToString().substr(0,14).c_str());
+
+    // Preliminary checks
+    if (!pblock->CheckBlock())
+    {
+        delete pblock;
+        return error("ProcessBlock() : CheckBlock FAILED");
+    }
+
+    // If don't already have its previous block, shunt it off to holding area until we get it
+    if (!mapBlockIndex.count(pblock->hashPrevBlock))
+    {
+        printf("ProcessBlock: ORPHAN BLOCK, prev=%s\n", pblock->hashPrevBlock.ToString().substr(0,14).c_str());
+        mapOrphanBlocks.insert(make_pair(hash, pblock));
+        mapOrphanBlocksByPrev.insert(make_pair(pblock->hashPrevBlock, pblock));
+
+        // Ask this guy to fill in what we're missing
+        if (pfrom)
+            pfrom->PushMessage("getblocks", CBlockLocator(pindexBest), GetOrphanRoot(pblock));
+        return true;
+    }
+
+    // Store to disk
+    if (!pblock->AcceptBlock())
+    {
+        delete pblock;
+        return error("ProcessBlock() : AcceptBlock FAILED");
+    }
+    delete pblock;
+
+    // Recursively process any orphan blocks that depended on this one
+    vector<uint256> vWorkQueue;
+    vWorkQueue.push_back(hash);
+    for (int i = 0; i < vWorkQueue.size(); i++)
+    {
+        uint256 hashPrev = vWorkQueue[i];
+        for (multimap<uint256, CBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);
+             mi != mapOrphanBlocksByPrev.upper_bound(hashPrev);
+             ++mi)
+        {
+            CBlock* pblockOrphan = (*mi).second;
+            if (pblockOrphan->AcceptBlock())
+                vWorkQueue.push_back(pblockOrphan->GetHash());
+            mapOrphanBlocks.erase(pblockOrphan->GetHash());
+            delete pblockOrphan;
+        }
+        mapOrphanBlocksByPrev.erase(hashPrev);
+    }
+
+    printf("ProcessBlock: ACCEPTED\n");
+    return true;
+}
+
+
+
+
+
+
+
+
+template<typename Stream>
+bool ScanMessageStart(Stream& s)
+{
+    // Scan ahead to the next pchMessageStart, which should normally be immediately
+    // at the file pointer.  Leaves file pointer at end of pchMessageStart.
+    s.clear(0);
+    short prevmask = s.exceptions(0);
+    const char* p = BEGIN(pchMessageStart);
+    try
+    {
+        loop
+        {
+            char c;
+            s.read(&c, 1);
+            if (s.fail())
+            {
+                s.clear(0);
+                s.exceptions(prevmask);
+                return false;
+            }
+            if (*p != c)
+                p = BEGIN(pchMessageStart);
+            if (*p == c)
+            {
+                if (++p == END(pchMessageStart))
+                {
+                    s.clear(0);
+                    s.exceptions(prevmask);
+                    return true;
+                }
+            }
+        }
+    }
+    catch (...)
+    {
+        s.clear(0);
+        s.exceptions(prevmask);
+        return false;
+    }
+}
+
+string GetAppDir()
+{
+    string strDir;
+    if (!strSetDataDir.empty())
+    {
+        strDir = strSetDataDir;
+    }
+    else if (getenv("APPDATA"))
+    {
+        strDir = strprintf("%s\\Bitcoin", getenv("APPDATA"));
+    }
+    else if (getenv("USERPROFILE"))
+    {
+        string strAppData = strprintf("%s\\Application Data", getenv("USERPROFILE"));
+        static bool fMkdirDone;
+        if (!fMkdirDone)
+        {
+            fMkdirDone = true;
+            _mkdir(strAppData.c_str());
+        }
+        strDir = strprintf("%s\\Bitcoin", strAppData.c_str());
+    }
+    else
+    {
+        return ".";
+    }
+    static bool fMkdirDone;
+    if (!fMkdirDone)
+    {
+        fMkdirDone = true;
+        _mkdir(strDir.c_str());
+    }
+    return strDir;
+}
+
+bool CheckDiskSpace(int64 nAdditionalBytes)
+{
+    uint64 nFreeBytesAvailable = 0;     // bytes available to caller
+    uint64 nTotalNumberOfBytes = 0;     // bytes on disk
+    uint64 nTotalNumberOfFreeBytes = 0; // free bytes on disk
+
+    if (!GetDiskFreeSpaceEx(GetAppDir().c_str(),
+            (PULARGE_INTEGER)&nFreeBytesAvailable,
+            (PULARGE_INTEGER)&nTotalNumberOfBytes,
+            (PULARGE_INTEGER)&nTotalNumberOfFreeBytes))
+    {
+        printf("ERROR: GetDiskFreeSpaceEx() failed\n");
+        return true;
+    }
+
+    // Check for 15MB because database could create another 10MB log file at any time
+    if ((int64)nFreeBytesAvailable < 15000000 + nAdditionalBytes)
+    {
+        fShutdown = true;
+        wxMessageBox("Warning: Your disk space is low  ", "Bitcoin", wxICON_EXCLAMATION);
+        _beginthread(Shutdown, 0, NULL);
+        return false;
+    }
+    return true;
+}
+
+FILE* OpenBlockFile(unsigned int nFile, unsigned int nBlockPos, const char* pszMode)
+{
+    if (nFile == -1)
+        return NULL;
+    FILE* file = fopen(strprintf("%s\\blk%04d.dat", GetAppDir().c_str(), nFile).c_str(), pszMode);
+    if (!file)
+        return NULL;
+    if (nBlockPos != 0 && !strchr(pszMode, 'a') && !strchr(pszMode, 'w'))
+    {
+        if (fseek(file, nBlockPos, SEEK_SET) != 0)
+        {
+            fclose(file);
+            return NULL;
+        }
+    }
+    return file;
+}
+
+static unsigned int nCurrentBlockFile = 1;
+
+FILE* AppendBlockFile(unsigned int& nFileRet)
+{
+    nFileRet = 0;
+    loop
+    {
+        FILE* file = OpenBlockFile(nCurrentBlockFile, 0, "ab");
+        if (!file)
+            return NULL;
+        if (fseek(file, 0, SEEK_END) != 0)
+            return NULL;
+        // FAT32 filesize max 4GB, fseek and ftell max 2GB, so we must stay under 2GB
+        if (ftell(file) < 0x7F000000 - MAX_SIZE)
+        {
+            nFileRet = nCurrentBlockFile;
+            return file;
+        }
+        fclose(file);
+        nCurrentBlockFile++;
+    }
+}
+
+bool LoadBlockIndex(bool fAllowNew)
+{
+    //
+    // Load block index
+    //
+    CTxDB txdb("cr");
+    if (!txdb.LoadBlockIndex())
+        return false;
+    txdb.Close();
+
+    //
+    // Init with genesis block
+    //
+    if (mapBlockIndex.empty())
+    {
+        if (!fAllowNew)
+            return false;
+
+
+        // Genesis Block:
+        // GetHash()      = 0x000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f
+        // hashMerkleRoot = 0x4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b
+        // txNew.vin[0].scriptSig     = 486604799 4 0x736B6E616220726F662074756F6C69616220646E6F63657320666F206B6E697262206E6F20726F6C6C65636E61684320393030322F6E614A2F33302073656D695420656854
+        // txNew.vout[0].nValue       = 5000000000
+        // txNew.vout[0].scriptPubKey = 0x5F1DF16B2B704C8A578D0BBAF74D385CDE12C11EE50455F3C438EF4C3FBCF649B6DE611FEAE06279A60939E028A8D65C10B73071A6F16719274855FEB0FD8A6704 OP_CHECKSIG
+        // block.nVersion = 1
+        // block.nTime    = 1231006505
+        // block.nBits    = 0x1d00ffff
+        // block.nNonce   = 2083236893
+        // CBlock(hash=000000000019d6, ver=1, hashPrevBlock=00000000000000, hashMerkleRoot=4a5e1e, nTime=1231006505, nBits=1d00ffff, nNonce=2083236893, vtx=1)
+        //   CTransaction(hash=4a5e1e, ver=1, vin.size=1, vout.size=1, nLockTime=0)
+        //     CTxIn(COutPoint(000000, -1), coinbase 04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73)
+        //     CTxOut(nValue=50.00000000, scriptPubKey=0x5F1DF16B2B704C8A578D0B)
+        //   vMerkleTree: 4a5e1e
+
+        // Genesis block
+        char* pszTimestamp = "The Times 03/Jan/2009 Chancellor on brink of second bailout for banks";
+        CTransaction txNew;
+        txNew.vin.resize(1);
+        txNew.vout.resize(1);
+        txNew.vin[0].scriptSig     = CScript() << 486604799 << CBigNum(4) << vector<unsigned char>((unsigned char*)pszTimestamp, (unsigned char*)pszTimestamp + strlen(pszTimestamp));
+        txNew.vout[0].nValue       = 50 * COIN;
+        txNew.vout[0].scriptPubKey = CScript() << CBigNum("0x5F1DF16B2B704C8A578D0BBAF74D385CDE12C11EE50455F3C438EF4C3FBCF649B6DE611FEAE06279A60939E028A8D65C10B73071A6F16719274855FEB0FD8A6704") << OP_CHECKSIG;
+        CBlock block;
+        block.vtx.push_back(txNew);
+        block.hashPrevBlock = 0;
+        block.hashMerkleRoot = block.BuildMerkleTree();
+        block.nVersion = 1;
+        block.nTime    = 1231006505;
+        block.nBits    = 0x1d00ffff;
+        block.nNonce   = 2083236893;
+
+            //// debug print, delete this later
+            printf("%s\n", block.GetHash().ToString().c_str());
+            printf("%s\n", block.hashMerkleRoot.ToString().c_str());
+            printf("%s\n", hashGenesisBlock.ToString().c_str());
+            txNew.vout[0].scriptPubKey.print();
+            block.print();
+            assert(block.hashMerkleRoot == uint256("0x4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b"));
+
+        assert(block.GetHash() == hashGenesisBlock);
+
+        // Start new block file
+        unsigned int nFile;
+        unsigned int nBlockPos;
+        if (!block.WriteToDisk(!fClient, nFile, nBlockPos))
+            return error("LoadBlockIndex() : writing genesis block to disk failed");
+        if (!block.AddToBlockIndex(nFile, nBlockPos))
+            return error("LoadBlockIndex() : genesis block not accepted");
+    }
+
+    return true;
+}
+
+
+
+void PrintBlockTree()
+{
+    // precompute tree structure
+    map<CBlockIndex*, vector<CBlockIndex*> > mapNext;
+    for (map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.begin(); mi != mapBlockIndex.end(); ++mi)
+    {
+        CBlockIndex* pindex = (*mi).second;
+        mapNext[pindex->pprev].push_back(pindex);
+        // test
+        //while (rand() % 3 == 0)
+        //    mapNext[pindex->pprev].push_back(pindex);
+    }
+
+    vector<pair<int, CBlockIndex*> > vStack;
+    vStack.push_back(make_pair(0, pindexGenesisBlock));
+
+    int nPrevCol = 0;
+    while (!vStack.empty())
+    {
+        int nCol = vStack.back().first;
+        CBlockIndex* pindex = vStack.back().second;
+        vStack.pop_back();
+
+        // print split or gap
+        if (nCol > nPrevCol)
+        {
+            for (int i = 0; i < nCol-1; i++)
+                printf("| ");
+            printf("|\\\n");
+        }
+        else if (nCol < nPrevCol)
+        {
+            for (int i = 0; i < nCol; i++)
+                printf("| ");
+            printf("|\n");
+        }
+        nPrevCol = nCol;
+
+        // print columns
+        for (int i = 0; i < nCol; i++)
+            printf("| ");
+
+        // print item
+        CBlock block;
+        block.ReadFromDisk(pindex, true);
+        printf("%d (%u,%u) %s  %s  tx %d",
+            pindex->nHeight,
+            pindex->nFile,
+            pindex->nBlockPos,
+            block.GetHash().ToString().substr(0,14).c_str(),
+            DateTimeStr(block.nTime).c_str(),
+            block.vtx.size());
+
+        CRITICAL_BLOCK(cs_mapWallet)
+        {
+            if (mapWallet.count(block.vtx[0].GetHash()))
+            {
+                CWalletTx& wtx = mapWallet[block.vtx[0].GetHash()];
+                printf("    mine:  %d  %d  %d", wtx.GetDepthInMainChain(), wtx.GetBlocksToMaturity(), wtx.GetCredit());
+            }
+        }
+        printf("\n");
+
+
+        // put the main timechain first
+        vector<CBlockIndex*>& vNext = mapNext[pindex];
+        for (int i = 0; i < vNext.size(); i++)
+        {
+            if (vNext[i]->pnext)
+            {
+                swap(vNext[0], vNext[i]);
+                break;
+            }
+        }
+
+        // iterate children
+        for (int i = 0; i < vNext.size(); i++)
+            vStack.push_back(make_pair(nCol+i, vNext[i]));
+    }
+}
+
+
+
+
+
+
+
+
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// Messages
+//
+
+
+bool AlreadyHave(CTxDB& txdb, const CInv& inv)
+{
+    switch (inv.type)
+    {
+    case MSG_TX:        return mapTransactions.count(inv.hash) || txdb.ContainsTx(inv.hash);
+    case MSG_BLOCK:     return mapBlockIndex.count(inv.hash) || mapOrphanBlocks.count(inv.hash);
+    case MSG_REVIEW:    return true;
+    case MSG_PRODUCT:   return mapProducts.count(inv.hash);
+    }
+    // Don't know what it is, just say we already got one
+    return true;
+}
+
+
+
+
+
+
+
+bool ProcessMessages(CNode* pfrom)
+{
+    CDataStream& vRecv = pfrom->vRecv;
+    if (vRecv.empty())
+        return true;
+    printf("ProcessMessages(%d bytes)\n", vRecv.size());
+
+    //
+    // Message format
+    //  (4) message start
+    //  (12) command
+    //  (4) size
+    //  (x) data
+    //
+
+    loop
+    {
+        // Scan for message start
+        CDataStream::iterator pstart = search(vRecv.begin(), vRecv.end(), BEGIN(pchMessageStart), END(pchMessageStart));
+        if (vRecv.end() - pstart < sizeof(CMessageHeader))
+        {
+            if (vRecv.size() > sizeof(CMessageHeader))
+            {
+                printf("\n\nPROCESSMESSAGE MESSAGESTART NOT FOUND\n\n");
+                vRecv.erase(vRecv.begin(), vRecv.end() - sizeof(CMessageHeader));
+            }
+            break;
+        }
+        if (pstart - vRecv.begin() > 0)
+            printf("\n\nPROCESSMESSAGE SKIPPED %d BYTES\n\n", pstart - vRecv.begin());
+        vRecv.erase(vRecv.begin(), pstart);
+
+        // Read header
+        CMessageHeader hdr;
+        vRecv >> hdr;
+        if (!hdr.IsValid())
+        {
+            printf("\n\nPROCESSMESSAGE: ERRORS IN HEADER %s\n\n\n", hdr.GetCommand().c_str());
+            continue;
+        }
+        string strCommand = hdr.GetCommand();
+
+        // Message size
+        unsigned int nMessageSize = hdr.nMessageSize;
+        if (nMessageSize > vRecv.size())
+        {
+            // Rewind and wait for rest of message
+            ///// need a mechanism to give up waiting for overlong message size error
+            printf("MESSAGE-BREAK\n");
+            vRecv.insert(vRecv.begin(), BEGIN(hdr), END(hdr));
+            Sleep(100);
+            break;
+        }
+
+        // Copy message to its own buffer
+        CDataStream vMsg(vRecv.begin(), vRecv.begin() + nMessageSize, vRecv.nType, vRecv.nVersion);
+        vRecv.ignore(nMessageSize);
+
+        // Process message
+        bool fRet = false;
+        try
+        {
+            CheckForShutdown(2);
+            CRITICAL_BLOCK(cs_main)
+                fRet = ProcessMessage(pfrom, strCommand, vMsg);
+            CheckForShutdown(2);
+        }
+        CATCH_PRINT_EXCEPTION("ProcessMessage()")
+        if (!fRet)
+            printf("ProcessMessage(%s, %d bytes) from %s to %s FAILED\n", strCommand.c_str(), nMessageSize, pfrom->addr.ToString().c_str(), addrLocalHost.ToString().c_str());
+    }
+
+    vRecv.Compact();
+    return true;
+}
+
+
+
+
+bool ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)
+{
+    static map<unsigned int, vector<unsigned char> > mapReuseKey;
+    printf("received: %-12s (%d bytes)  ", strCommand.c_str(), vRecv.size());
+    for (int i = 0; i < min(vRecv.size(), (unsigned int)20); i++)
+        printf("%02x ", vRecv[i] & 0xff);
+    printf("\n");
+    if (nDropMessagesTest > 0 && GetRand(nDropMessagesTest) == 0)
+    {
+        printf("dropmessages DROPPING RECV MESSAGE\n");
+        return true;
+    }
+
+
+
+    if (strCommand == "version")
+    {
+        // Can only do this once
+        if (pfrom->nVersion != 0)
+            return false;
+
+        int64 nTime;
+        CAddress addrMe;
+        vRecv >> pfrom->nVersion >> pfrom->nServices >> nTime >> addrMe;
+        if (pfrom->nVersion == 0)
+            return false;
+
+        pfrom->vSend.SetVersion(min(pfrom->nVersion, VERSION));
+        pfrom->vRecv.SetVersion(min(pfrom->nVersion, VERSION));
+
+        pfrom->fClient = !(pfrom->nServices & NODE_NETWORK);
+        if (pfrom->fClient)
+        {
+            pfrom->vSend.nType |= SER_BLOCKHEADERONLY;
+            pfrom->vRecv.nType |= SER_BLOCKHEADERONLY;
+        }
+
+        AddTimeData(pfrom->addr.ip, nTime);
+
+        // Ask the first connected node for block updates
+        static bool fAskedForBlocks;
+        if (!fAskedForBlocks && !pfrom->fClient)
+        {
+            fAskedForBlocks = true;
+            pfrom->PushMessage("getblocks", CBlockLocator(pindexBest), uint256(0));
+        }
+
+        printf("version message: %s has version %d, addrMe=%s\n", pfrom->addr.ToString().c_str(), pfrom->nVersion, addrMe.ToString().c_str());
+    }
+
+
+    else if (pfrom->nVersion == 0)
+    {
+        // Must have a version message before anything else
+        return false;
+    }
+
+
+    else if (strCommand == "addr")
+    {
+        vector<CAddress> vAddr;
+        vRecv >> vAddr;
+
+        // Store the new addresses
+        CAddrDB addrdb;
+        foreach(const CAddress& addr, vAddr)
+        {
+            if (fShutdown)
+                return true;
+            if (AddAddress(addrdb, addr))
+            {
+                // Put on lists to send to other nodes
+                pfrom->setAddrKnown.insert(addr);
+                CRITICAL_BLOCK(cs_vNodes)
+                    foreach(CNode* pnode, vNodes)
+                        if (!pnode->setAddrKnown.count(addr))
+                            pnode->vAddrToSend.push_back(addr);
+            }
+        }
+    }
+
+
+    else if (strCommand == "inv")
+    {
+        vector<CInv> vInv;
+        vRecv >> vInv;
+
+        CTxDB txdb("r");
+        foreach(const CInv& inv, vInv)
+        {
+            if (fShutdown)
+                return true;
+            pfrom->AddInventoryKnown(inv);
+
+            bool fAlreadyHave = AlreadyHave(txdb, inv);
+            printf("  got inventory: %s  %s\n", inv.ToString().c_str(), fAlreadyHave ? "have" : "new");
+
+            if (!fAlreadyHave)
+                pfrom->AskFor(inv);
+            else if (inv.type == MSG_BLOCK && mapOrphanBlocks.count(inv.hash))
+                pfrom->PushMessage("getblocks", CBlockLocator(pindexBest), GetOrphanRoot(mapOrphanBlocks[inv.hash]));
+        }
+    }
+
+
+    else if (strCommand == "getdata")
+    {
+        vector<CInv> vInv;
+        vRecv >> vInv;
+
+        foreach(const CInv& inv, vInv)
+        {
+            if (fShutdown)
+                return true;
+            printf("received getdata for: %s\n", inv.ToString().c_str());
+
+            if (inv.type == MSG_BLOCK)
+            {
+                // Send block from disk
+                map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(inv.hash);
+                if (mi != mapBlockIndex.end())
+                {
+                    //// could optimize this to send header straight from blockindex for client
+                    CBlock block;
+                    block.ReadFromDisk((*mi).second, !pfrom->fClient);
+                    pfrom->PushMessage("block", block);
+                }
+            }
+            else if (inv.IsKnownType())
+            {
+                // Send stream from relay memory
+                CRITICAL_BLOCK(cs_mapRelay)
+                {
+                    map<CInv, CDataStream>::iterator mi = mapRelay.find(inv);
+                    if (mi != mapRelay.end())
+                        pfrom->PushMessage(inv.GetCommand(), (*mi).second);
+                }
+            }
+        }
+    }
+
+
+    else if (strCommand == "getblocks")
+    {
+        CBlockLocator locator;
+        uint256 hashStop;
+        vRecv >> locator >> hashStop;
+
+        // Find the first block the caller has in the main chain
+        CBlockIndex* pindex = locator.GetBlockIndex();
+
+        // Send the rest of the chain
+        if (pindex)
+            pindex = pindex->pnext;
+        printf("getblocks %d to %s\n", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,14).c_str());
+        for (; pindex; pindex = pindex->pnext)
+        {
+            if (pindex->GetBlockHash() == hashStop)
+            {
+                printf("  getblocks stopping at %d %s\n", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,14).c_str());
+                break;
+            }
+
+            // Bypass setInventoryKnown in case an inventory message got lost
+            CRITICAL_BLOCK(pfrom->cs_inventory)
+            {
+                CInv inv(MSG_BLOCK, pindex->GetBlockHash());
+                // returns true if wasn't already contained in the set
+                if (pfrom->setInventoryKnown2.insert(inv).second)
+                {
+                    pfrom->setInventoryKnown.erase(inv);
+                    pfrom->vInventoryToSend.push_back(inv);
+                }
+            }
+        }
+    }
+
+
+    else if (strCommand == "tx")
+    {
+        vector<uint256> vWorkQueue;
+        CDataStream vMsg(vRecv);
+        CTransaction tx;
+        vRecv >> tx;
+
+        CInv inv(MSG_TX, tx.GetHash());
+        pfrom->AddInventoryKnown(inv);
+
+        bool fMissingInputs = false;
+        if (tx.AcceptTransaction(true, &fMissingInputs))
+        {
+            AddToWalletIfMine(tx, NULL);
+            RelayMessage(inv, vMsg);
+            mapAlreadyAskedFor.erase(inv);
+            vWorkQueue.push_back(inv.hash);
+
+            // Recursively process any orphan transactions that depended on this one
+            for (int i = 0; i < vWorkQueue.size(); i++)
+            {
+                uint256 hashPrev = vWorkQueue[i];
+                for (multimap<uint256, CDataStream*>::iterator mi = mapOrphanTransactionsByPrev.lower_bound(hashPrev);
+                     mi != mapOrphanTransactionsByPrev.upper_bound(hashPrev);
+                     ++mi)
+                {
+                    const CDataStream& vMsg = *((*mi).second);
+                    CTransaction tx;
+                    CDataStream(vMsg) >> tx;
+                    CInv inv(MSG_TX, tx.GetHash());
+
+                    if (tx.AcceptTransaction(true))
+                    {
+                        printf("   accepted orphan tx %s\n", inv.hash.ToString().substr(0,6).c_str());
+                        AddToWalletIfMine(tx, NULL);
+                        RelayMessage(inv, vMsg);
+                        mapAlreadyAskedFor.erase(inv);
+                        vWorkQueue.push_back(inv.hash);
+                    }
+                }
+            }
+
+            foreach(uint256 hash, vWorkQueue)
+                EraseOrphanTx(hash);
+        }
+        else if (fMissingInputs)
+        {
+            printf("storing orphan tx %s\n", inv.hash.ToString().substr(0,6).c_str());
+            AddOrphanTx(vMsg);
+        }
+    }
+
+
+    else if (strCommand == "review")
+    {
+        CDataStream vMsg(vRecv);
+        CReview review;
+        vRecv >> review;
+
+        CInv inv(MSG_REVIEW, review.GetHash());
+        pfrom->AddInventoryKnown(inv);
+
+        if (review.AcceptReview())
+        {
+            // Relay the original message as-is in case it's a higher version than we know how to parse
+            RelayMessage(inv, vMsg);
+            mapAlreadyAskedFor.erase(inv);
+        }
+    }
+
+
+    else if (strCommand == "block")
+    {
+        auto_ptr<CBlock> pblock(new CBlock);
+        vRecv >> *pblock;
+
+        //// debug print
+        printf("received block:\n"); pblock->print();
+
+        CInv inv(MSG_BLOCK, pblock->GetHash());
+        pfrom->AddInventoryKnown(inv);
+
+        if (ProcessBlock(pfrom, pblock.release()))
+            mapAlreadyAskedFor.erase(inv);
+    }
+
+
+    else if (strCommand == "getaddr")
+    {
+        pfrom->vAddrToSend.clear();
+        int64 nSince = GetAdjustedTime() - 5 * 24 * 60 * 60; // in the last 5 days
+        CRITICAL_BLOCK(cs_mapAddresses)
+        {
+            unsigned int nSize = mapAddresses.size();
+            foreach(const PAIRTYPE(vector<unsigned char>, CAddress)& item, mapAddresses)
+            {
+                if (fShutdown)
+                    return true;
+                const CAddress& addr = item.second;
+                //// will need this if we lose IRC
+                //if (addr.nTime > nSince || (rand() % nSize) < 500)
+                if (addr.nTime > nSince)
+                    pfrom->vAddrToSend.push_back(addr);
+            }
+        }
+    }
+
+
+    else if (strCommand == "checkorder")
+    {
+        uint256 hashReply;
+        CWalletTx order;
+        vRecv >> hashReply >> order;
+
+        /// we have a chance to check the order here
+
+        // Keep giving the same key to the same ip until they use it
+        if (!mapReuseKey.count(pfrom->addr.ip))
+            mapReuseKey[pfrom->addr.ip] = GenerateNewKey();
+
+        // Send back approval of order and pubkey to use
+        CScript scriptPubKey;
+        scriptPubKey << mapReuseKey[pfrom->addr.ip] << OP_CHECKSIG;
+        pfrom->PushMessage("reply", hashReply, (int)0, scriptPubKey);
+    }
+
+
+    else if (strCommand == "submitorder")
+    {
+        uint256 hashReply;
+        CWalletTx wtxNew;
+        vRecv >> hashReply >> wtxNew;
+
+        // Broadcast
+        if (!wtxNew.AcceptWalletTransaction())
+        {
+            pfrom->PushMessage("reply", hashReply, (int)1);
+            return error("submitorder AcceptWalletTransaction() failed, returning error 1");
+        }
+        wtxNew.fTimeReceivedIsTxTime = true;
+        AddToWallet(wtxNew);
+        wtxNew.RelayWalletTransaction();
+        mapReuseKey.erase(pfrom->addr.ip);
+
+        // Send back confirmation
+        pfrom->PushMessage("reply", hashReply, (int)0);
+    }
+
+
+    else if (strCommand == "reply")
+    {
+        uint256 hashReply;
+        vRecv >> hashReply;
+
+        CRequestTracker tracker;
+        CRITICAL_BLOCK(pfrom->cs_mapRequests)
+        {
+            map<uint256, CRequestTracker>::iterator mi = pfrom->mapRequests.find(hashReply);
+            if (mi != pfrom->mapRequests.end())
+            {
+                tracker = (*mi).second;
+                pfrom->mapRequests.erase(mi);
+            }
+        }
+        if (!tracker.IsNull())
+            tracker.fn(tracker.param1, vRecv);
+    }
+
+
+    else
+    {
+        // Ignore unknown commands for extensibility
+        printf("ProcessMessage(%s) : Ignored unknown message\n", strCommand.c_str());
+    }
+
+
+    if (!vRecv.empty())
+        printf("ProcessMessage(%s) : %d extra bytes\n", strCommand.c_str(), vRecv.size());
+
+    return true;
+}
+
+
+
+
+
+
+
+
+
+bool SendMessages(CNode* pto)
+{
+    CheckForShutdown(2);
+    CRITICAL_BLOCK(cs_main)
+    {
+        // Don't send anything until we get their version message
+        if (pto->nVersion == 0)
+            return true;
+
+
+        //
+        // Message: addr
+        //
+        vector<CAddress> vAddrToSend;
+        vAddrToSend.reserve(pto->vAddrToSend.size());
+        foreach(const CAddress& addr, pto->vAddrToSend)
+            if (!pto->setAddrKnown.count(addr))
+                vAddrToSend.push_back(addr);
+        pto->vAddrToSend.clear();
+        if (!vAddrToSend.empty())
+            pto->PushMessage("addr", vAddrToSend);
+
+
+        //
+        // Message: inventory
+        //
+        vector<CInv> vInventoryToSend;
+        CRITICAL_BLOCK(pto->cs_inventory)
+        {
+            vInventoryToSend.reserve(pto->vInventoryToSend.size());
+            foreach(const CInv& inv, pto->vInventoryToSend)
+            {
+                // returns true if wasn't already contained in the set
+                if (pto->setInventoryKnown.insert(inv).second)
+                    vInventoryToSend.push_back(inv);
+            }
+            pto->vInventoryToSend.clear();
+            pto->setInventoryKnown2.clear();
+        }
+        if (!vInventoryToSend.empty())
+            pto->PushMessage("inv", vInventoryToSend);
+
+
+        //
+        // Message: getdata
+        //
+        vector<CInv> vAskFor;
+        int64 nNow = GetTime() * 1000000;
+        CTxDB txdb("r");
+        while (!pto->mapAskFor.empty() && (*pto->mapAskFor.begin()).first <= nNow)
+        {
+            const CInv& inv = (*pto->mapAskFor.begin()).second;
+            printf("sending getdata: %s\n", inv.ToString().c_str());
+            if (!AlreadyHave(txdb, inv))
+                vAskFor.push_back(inv);
+            pto->mapAskFor.erase(pto->mapAskFor.begin());
+        }
+        if (!vAskFor.empty())
+            pto->PushMessage("getdata", vAskFor);
+
+    }
+    return true;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// BitcoinMiner
+//
+
+int FormatHashBlocks(void* pbuffer, unsigned int len)
+{
+    unsigned char* pdata = (unsigned char*)pbuffer;
+    unsigned int blocks = 1 + ((len + 8) / 64);
+    unsigned char* pend = pdata + 64 * blocks;
+    memset(pdata + len, 0, 64 * blocks - len);
+    pdata[len] = 0x80;
+    unsigned int bits = len * 8;
+    pend[-1] = (bits >> 0) & 0xff;
+    pend[-2] = (bits >> 8) & 0xff;
+    pend[-3] = (bits >> 16) & 0xff;
+    pend[-4] = (bits >> 24) & 0xff;
+    return blocks;
+}
+
+using CryptoPP::ByteReverse;
+static int detectlittleendian = 1;
+
+void BlockSHA256(const void* pin, unsigned int nBlocks, void* pout)
+{
+    unsigned int* pinput = (unsigned int*)pin;
+    unsigned int* pstate = (unsigned int*)pout;
+
+    CryptoPP::SHA256::InitState(pstate);
+
+    if (*(char*)&detectlittleendian != 0)
+    {
+        for (int n = 0; n < nBlocks; n++)
+        {
+            unsigned int pbuf[16];
+            for (int i = 0; i < 16; i++)
+                pbuf[i] = ByteReverse(pinput[n * 16 + i]);
+            CryptoPP::SHA256::Transform(pstate, pbuf);
+        }
+        for (int i = 0; i < 8; i++)
+            pstate[i] = ByteReverse(pstate[i]);
+    }
+    else
+    {
+        for (int n = 0; n < nBlocks; n++)
+            CryptoPP::SHA256::Transform(pstate, pinput + n * 16);
+    }
+}
+
+
+bool BitcoinMiner()
+{
+    printf("BitcoinMiner started\n");
+    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_LOWEST);
+
+    CKey key;
+    key.MakeNewKey();
+    CBigNum bnExtraNonce = 0;
+    while (fGenerateBitcoins)
+    {
+        Sleep(50);
+        CheckForShutdown(3);
+        while (vNodes.empty())
+        {
+            Sleep(1000);
+            CheckForShutdown(3);
+        }
+
+        unsigned int nTransactionsUpdatedLast = nTransactionsUpdated;
+        CBlockIndex* pindexPrev = pindexBest;
+        unsigned int nBits = GetNextWorkRequired(pindexPrev);
+
+
+        //
+        // Create coinbase tx
+        //
+        CTransaction txNew;
+        txNew.vin.resize(1);
+        txNew.vin[0].prevout.SetNull();
+        txNew.vin[0].scriptSig << nBits << ++bnExtraNonce;
+        txNew.vout.resize(1);
+        txNew.vout[0].scriptPubKey << key.GetPubKey() << OP_CHECKSIG;
+
+
+        //
+        // Create new block
+        //
+        auto_ptr<CBlock> pblock(new CBlock());
+        if (!pblock.get())
+            return false;
+
+        // Add our coinbase tx as first transaction
+        pblock->vtx.push_back(txNew);
+
+        // Collect the latest transactions into the block
+        int64 nFees = 0;
+        CRITICAL_BLOCK(cs_main)
+        CRITICAL_BLOCK(cs_mapTransactions)
+        {
+            CTxDB txdb("r");
+            map<uint256, CTxIndex> mapTestPool;
+            vector<char> vfAlreadyAdded(mapTransactions.size());
+            bool fFoundSomething = true;
+            unsigned int nBlockSize = 0;
+            while (fFoundSomething && nBlockSize < MAX_SIZE/2)
+            {
+                fFoundSomething = false;
+                unsigned int n = 0;
+                for (map<uint256, CTransaction>::iterator mi = mapTransactions.begin(); mi != mapTransactions.end(); ++mi, ++n)
+                {
+                    if (vfAlreadyAdded[n])
+                        continue;
+                    CTransaction& tx = (*mi).second;
+                    if (tx.IsCoinBase() || !tx.IsFinal())
+                        continue;
+
+                    // Transaction fee requirements, mainly only needed for flood control
+                    // Under 10K (about 80 inputs) is free for first 100 transactions
+                    // Base rate is 0.01 per KB
+                    int64 nMinFee = tx.GetMinFee(pblock->vtx.size() < 100);
+
+                    map<uint256, CTxIndex> mapTestPoolTmp(mapTestPool);
+                    if (!tx.ConnectInputs(txdb, mapTestPoolTmp, CDiskTxPos(1,1,1), 0, nFees, false, true, nMinFee))
+                        continue;
+                    swap(mapTestPool, mapTestPoolTmp);
+
+                    pblock->vtx.push_back(tx);
+                    nBlockSize += ::GetSerializeSize(tx, SER_NETWORK);
+                    vfAlreadyAdded[n] = true;
+                    fFoundSomething = true;
+                }
+            }
+        }
+        pblock->nBits = nBits;
+        pblock->vtx[0].vout[0].nValue = pblock->GetBlockValue(nFees);
+        printf("\n\nRunning BitcoinMiner with %d transactions in block\n", pblock->vtx.size());
+
+
+        //
+        // Prebuild hash buffer
+        //
+        struct unnamed1
+        {
+            struct unnamed2
+            {
+                int nVersion;
+                uint256 hashPrevBlock;
+                uint256 hashMerkleRoot;
+                unsigned int nTime;
+                unsigned int nBits;
+                unsigned int nNonce;
+            }
+            block;
+            unsigned char pchPadding0[64];
+            uint256 hash1;
+            unsigned char pchPadding1[64];
+        }
+        tmp;
+
+        tmp.block.nVersion       = pblock->nVersion;
+        tmp.block.hashPrevBlock  = pblock->hashPrevBlock  = (pindexPrev ? pindexPrev->GetBlockHash() : 0);
+        tmp.block.hashMerkleRoot = pblock->hashMerkleRoot = pblock->BuildMerkleTree();
+        tmp.block.nTime          = pblock->nTime          = max((pindexPrev ? pindexPrev->GetMedianTimePast()+1 : 0), GetAdjustedTime());
+        tmp.block.nBits          = pblock->nBits          = nBits;
+        tmp.block.nNonce         = pblock->nNonce         = 1;
+
+        unsigned int nBlocks0 = FormatHashBlocks(&tmp.block, sizeof(tmp.block));
+        unsigned int nBlocks1 = FormatHashBlocks(&tmp.hash1, sizeof(tmp.hash1));
+
+
+        //
+        // Search
+        //
+        unsigned int nStart = GetTime();
+        uint256 hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();
+        uint256 hash;
+        loop
+        {
+            BlockSHA256(&tmp.block, nBlocks0, &tmp.hash1);
+            BlockSHA256(&tmp.hash1, nBlocks1, &hash);
+
+
+            if (hash <= hashTarget)
+            {
+                pblock->nNonce = tmp.block.nNonce;
+                assert(hash == pblock->GetHash());
+
+                    //// debug print
+                    printf("BitcoinMiner:\n");
+                    printf("proof-of-work found  \n  hash: %s  \ntarget: %s\n", hash.GetHex().c_str(), hashTarget.GetHex().c_str());
+                    pblock->print();
+
+                SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);
+                CRITICAL_BLOCK(cs_main)
+                {
+                    // Save key
+                    if (!AddKey(key))
+                        return false;
+                    key.MakeNewKey();
+
+                    // Process this block the same as if we had received it from another node
+                    if (!ProcessBlock(NULL, pblock.release()))
+                        printf("ERROR in BitcoinMiner, ProcessBlock, block not accepted\n");
+                }
+                SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_LOWEST);
+
+                Sleep(500);
+                break;
+            }
+
+            // Update nTime every few seconds
+            if ((++tmp.block.nNonce & 0x3ffff) == 0)
+            {
+                CheckForShutdown(3);
+                if (tmp.block.nNonce == 0)
+                    break;
+                if (pindexPrev != pindexBest)
+                    break;
+                if (nTransactionsUpdated != nTransactionsUpdatedLast && GetTime() - nStart > 60)
+                    break;
+                if (!fGenerateBitcoins)
+                    break;
+                tmp.block.nTime = pblock->nTime = max(pindexPrev->GetMedianTimePast()+1, GetAdjustedTime());
+            }
+        }
+    }
+
+    return true;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+//////////////////////////////////////////////////////////////////////////////
+//
+// Actions
+//
+
+
+int64 GetBalance()
+{
+    int64 nStart, nEnd;
+    QueryPerformanceCounter((LARGE_INTEGER*)&nStart);
+
+    int64 nTotal = 0;
+    CRITICAL_BLOCK(cs_mapWallet)
+    {
+        for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)
+        {
+            CWalletTx* pcoin = &(*it).second;
+            if (!pcoin->IsFinal() || pcoin->fSpent)
+                continue;
+            nTotal += pcoin->GetCredit();
+        }
+    }
+
+    QueryPerformanceCounter((LARGE_INTEGER*)&nEnd);
+    ///printf(" GetBalance() time = %16I64d\n", nEnd - nStart);
+    return nTotal;
+}
+
+
+
+bool SelectCoins(int64 nTargetValue, set<CWalletTx*>& setCoinsRet)
+{
+    setCoinsRet.clear();
+
+    // List of values less than target
+    int64 nLowestLarger = _I64_MAX;
+    CWalletTx* pcoinLowestLarger = NULL;
+    vector<pair<int64, CWalletTx*> > vValue;
+    int64 nTotalLower = 0;
+
+    CRITICAL_BLOCK(cs_mapWallet)
+    {
+        for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)
+        {
+            CWalletTx* pcoin = &(*it).second;
+            if (!pcoin->IsFinal() || pcoin->fSpent)
+                continue;
+            int64 n = pcoin->GetCredit();
+            if (n <= 0)
+                continue;
+            if (n < nTargetValue)
+            {
+                vValue.push_back(make_pair(n, pcoin));
+                nTotalLower += n;
+            }
+            else if (n == nTargetValue)
+            {
+                setCoinsRet.insert(pcoin);
+                return true;
+            }
+            else if (n < nLowestLarger)
+            {
+                nLowestLarger = n;
+                pcoinLowestLarger = pcoin;
+            }
+        }
+    }
+
+    if (nTotalLower < nTargetValue)
+    {
+        if (pcoinLowestLarger == NULL)
+            return false;
+        setCoinsRet.insert(pcoinLowestLarger);
+        return true;
+    }
+
+    // Solve subset sum by stochastic approximation
+    sort(vValue.rbegin(), vValue.rend());
+    vector<char> vfIncluded;
+    vector<char> vfBest(vValue.size(), true);
+    int64 nBest = nTotalLower;
+
+    for (int nRep = 0; nRep < 1000 && nBest != nTargetValue; nRep++)
+    {
+        vfIncluded.assign(vValue.size(), false);
+        int64 nTotal = 0;
+        bool fReachedTarget = false;
+        for (int nPass = 0; nPass < 2 && !fReachedTarget; nPass++)
+        {
+            for (int i = 0; i < vValue.size(); i++)
+            {
+                if (nPass == 0 ? rand() % 2 : !vfIncluded[i])
+                {
+                    nTotal += vValue[i].first;
+                    vfIncluded[i] = true;
+                    if (nTotal >= nTargetValue)
+                    {
+                        fReachedTarget = true;
+                        if (nTotal < nBest)
+                        {
+                            nBest = nTotal;
+                            vfBest = vfIncluded;
+                        }
+                        nTotal -= vValue[i].first;
+                        vfIncluded[i] = false;
+                    }
+                }
+            }
+        }
+    }
+
+    // If the next larger is still closer, return it
+    if (pcoinLowestLarger && nLowestLarger - nTargetValue <= nBest - nTargetValue)
+        setCoinsRet.insert(pcoinLowestLarger);
+    else
+    {
+        for (int i = 0; i < vValue.size(); i++)
+            if (vfBest[i])
+                setCoinsRet.insert(vValue[i].second);
+
+        //// debug print
+        printf("SelectCoins() best subset: ");
+        for (int i = 0; i < vValue.size(); i++)
+            if (vfBest[i])
+                printf("%s ", FormatMoney(vValue[i].first).c_str());
+        printf("total %s\n", FormatMoney(nBest).c_str());
+    }
+
+    return true;
+}
+
+
+
+
+bool CreateTransaction(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew, int64& nFeeRequiredRet)
+{
+    nFeeRequiredRet = 0;
+    CRITICAL_BLOCK(cs_main)
+    {
+        // txdb must be opened before the mapWallet lock
+        CTxDB txdb("r");
+        CRITICAL_BLOCK(cs_mapWallet)
+        {
+            int64 nFee = nTransactionFee;
+            loop
+            {
+                wtxNew.vin.clear();
+                wtxNew.vout.clear();
+                if (nValue < 0)
+                    return false;
+                int64 nValueOut = nValue;
+                nValue += nFee;
+
+                // Choose coins to use
+                set<CWalletTx*> setCoins;
+                if (!SelectCoins(nValue, setCoins))
+                    return false;
+                int64 nValueIn = 0;
+                foreach(CWalletTx* pcoin, setCoins)
+                    nValueIn += pcoin->GetCredit();
+
+                // Fill vout[0] to the payee
+                wtxNew.vout.push_back(CTxOut(nValueOut, scriptPubKey));
+
+                // Fill vout[1] back to self with any change
+                if (nValueIn > nValue)
+                {
+                    /// todo: for privacy, should randomize the order of outputs,
+                    //        would also have to use a new key for the change.
+                    // Use the same key as one of the coins
+                    vector<unsigned char> vchPubKey;
+                    CTransaction& txFirst = *(*setCoins.begin());
+                    foreach(const CTxOut& txout, txFirst.vout)
+                        if (txout.IsMine())
+                            if (ExtractPubKey(txout.scriptPubKey, true, vchPubKey))
+                                break;
+                    if (vchPubKey.empty())
+                        return false;
+
+                    // Fill vout[1] to ourself
+                    CScript scriptPubKey;
+                    scriptPubKey << vchPubKey << OP_CHECKSIG;
+                    wtxNew.vout.push_back(CTxOut(nValueIn - nValue, scriptPubKey));
+                }
+
+                // Fill vin
+                foreach(CWalletTx* pcoin, setCoins)
+                    for (int nOut = 0; nOut < pcoin->vout.size(); nOut++)
+                        if (pcoin->vout[nOut].IsMine())
+                            wtxNew.vin.push_back(CTxIn(pcoin->GetHash(), nOut));
+
+                // Sign
+                int nIn = 0;
+                foreach(CWalletTx* pcoin, setCoins)
+                    for (int nOut = 0; nOut < pcoin->vout.size(); nOut++)
+                        if (pcoin->vout[nOut].IsMine())
+                            SignSignature(*pcoin, wtxNew, nIn++);
+
+                // Check that enough fee is included
+                if (nFee < wtxNew.GetMinFee(true))
+                {
+                    nFee = nFeeRequiredRet = wtxNew.GetMinFee(true);
+                    continue;
+                }
+
+                // Fill vtxPrev by copying from previous transactions vtxPrev
+                wtxNew.AddSupportingTransactions(txdb);
+                wtxNew.fTimeReceivedIsTxTime = true;
+
+                break;
+            }
+        }
+    }
+    return true;
+}
+
+// Call after CreateTransaction unless you want to abort
+bool CommitTransactionSpent(const CWalletTx& wtxNew)
+{
+    CRITICAL_BLOCK(cs_main)
+    CRITICAL_BLOCK(cs_mapWallet)
+    {
+        //// todo: make this transactional, never want to add a transaction
+        ////  without marking spent transactions
+
+        // Add tx to wallet, because if it has change it's also ours,
+        // otherwise just for transaction history.
+        AddToWallet(wtxNew);
+
+        // Mark old coins as spent
+        set<CWalletTx*> setCoins;
+        foreach(const CTxIn& txin, wtxNew.vin)
+            setCoins.insert(&mapWallet[txin.prevout.hash]);
+        foreach(CWalletTx* pcoin, setCoins)
+        {
+            pcoin->fSpent = true;
+            pcoin->WriteToDisk();
+            vWalletUpdated.push_back(make_pair(pcoin->GetHash(), false));
+        }
+    }
+    MainFrameRepaint();
+    return true;
+}
+
+
+
+
+bool SendMoney(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew)
+{
+    CRITICAL_BLOCK(cs_main)
+    {
+        int64 nFeeRequired;
+        if (!CreateTransaction(scriptPubKey, nValue, wtxNew, nFeeRequired))
+        {
+            string strError;
+            if (nValue + nFeeRequired > GetBalance())
+                strError = strprintf("Error: This is an oversized transaction that requires a transaction fee of %s  ", FormatMoney(nFeeRequired).c_str());
+            else
+                strError = "Error: Transaction creation failed  ";
+            wxMessageBox(strError, "Sending...");
+            return error("SendMoney() : %s\n", strError.c_str());
+        }
+        if (!CommitTransactionSpent(wtxNew))
+        {
+            wxMessageBox("Error finalizing transaction  ", "Sending...");
+            return error("SendMoney() : Error finalizing transaction");
+        }
+
+        printf("SendMoney: %s\n", wtxNew.GetHash().ToString().substr(0,6).c_str());
+
+        // Broadcast
+        if (!wtxNew.AcceptTransaction())
+        {
+            // This must not fail. The transaction has already been signed and recorded.
+            throw runtime_error("SendMoney() : wtxNew.AcceptTransaction() failed\n");
+            wxMessageBox("Error: Transaction not valid  ", "Sending...");
+            return error("SendMoney() : Error: Transaction not valid");
+        }
+        wtxNew.RelayWalletTransaction();
+    }
+    MainFrameRepaint();
+    return true;
+}
/trunk/main.h Diff Switch to side-by-side view
--- a
+++ b/trunk/main.h
@@ -0,0 +1,1329 @@
+// Copyright (c) 2009 Satoshi Nakamoto
+// Distributed under the MIT/X11 software license, see the accompanying
+// file license.txt or http://www.opensource.org/licenses/mit-license.php.
+
+class COutPoint;
+class CInPoint;
+class CDiskTxPos;
+class CCoinBase;
+class CTxIn;
+class CTxOut;
+class CTransaction;
+class CBlock;
+class CBlockIndex;
+class CWalletTx;
+class CKeyItem;
+
+static const unsigned int MAX_SIZE = 0x02000000;
+static const int64 COIN = 100000000;
+static const int64 CENT = 1000000;
+static const int COINBASE_MATURITY = 100;
+
+static const CBigNum bnProofOfWorkLimit(~uint256(0) >> 32);
+
+
+
+
+
+
+extern CCriticalSection cs_main;
+extern map<uint256, CBlockIndex*> mapBlockIndex;
+extern const uint256 hashGenesisBlock;
+extern CBlockIndex* pindexGenesisBlock;
+extern int nBestHeight;
+extern uint256 hashBestChain;
+extern CBlockIndex* pindexBest;
+extern unsigned int nTransactionsUpdated;
+extern string strSetDataDir;
+extern int nDropMessagesTest;
+
+// Settings
+extern int fGenerateBitcoins;
+extern int64 nTransactionFee;
+extern CAddress addrIncoming;
+
+
+
+
+
+
+
+string GetAppDir();
+bool CheckDiskSpace(int64 nAdditionalBytes=0);
+FILE* OpenBlockFile(unsigned int nFile, unsigned int nBlockPos, const char* pszMode="rb");
+FILE* AppendBlockFile(unsigned int& nFileRet);
+bool AddKey(const CKey& key);
+vector<unsigned char> GenerateNewKey();
+bool AddToWallet(const CWalletTx& wtxIn);
+void ReacceptWalletTransactions();
+void RelayWalletTransactions();
+bool LoadBlockIndex(bool fAllowNew=true);
+void PrintBlockTree();
+bool BitcoinMiner();
+bool ProcessMessages(CNode* pfrom);
+bool ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv);
+bool SendMessages(CNode* pto);
+int64 GetBalance();
+bool CreateTransaction(CScript scriptPubKey, int64 nValue, CWalletTx& txNew, int64& nFeeRequiredRet);
+bool CommitTransactionSpent(const CWalletTx& wtxNew);
+bool SendMoney(CScript scriptPubKey, int64 nValue, CWalletTx& wtxNew);
+
+
+
+
+
+
+
+
+
+
+
+class CDiskTxPos
+{
+public:
+    unsigned int nFile;
+    unsigned int nBlockPos;
+    unsigned int nTxPos;
+
+    CDiskTxPos()
+    {
+        SetNull();
+    }
+
+    CDiskTxPos(unsigned int nFileIn, unsigned int nBlockPosIn, unsigned int nTxPosIn)
+    {
+        nFile = nFileIn;
+        nBlockPos = nBlockPosIn;
+        nTxPos = nTxPosIn;
+    }
+
+    IMPLEMENT_SERIALIZE( READWRITE(FLATDATA(*this)); )
+    void SetNull() { nFile = -1; nBlockPos = 0; nTxPos = 0; }
+    bool IsNull() const { return (nFile == -1); }
+
+    friend bool operator==(const CDiskTxPos& a, const CDiskTxPos& b)
+    {
+        return (a.nFile     == b.nFile &&
+                a.nBlockPos == b.nBlockPos &&
+                a.nTxPos    == b.nTxPos);
+    }
+
+    friend bool operator!=(const CDiskTxPos& a, const CDiskTxPos& b)
+    {
+        return !(a == b);
+    }
+
+    string ToString() const
+    {
+        if (IsNull())
+            return strprintf("null");
+        else
+            return strprintf("(nFile=%d, nBlockPos=%d, nTxPos=%d)", nFile, nBlockPos, nTxPos);
+    }
+
+    void print() const
+    {
+        printf("%s", ToString().c_str());
+    }
+};
+
+
+
+
+class CInPoint
+{
+public:
+    CTransaction* ptx;
+    unsigned int n;
+
+    CInPoint() { SetNull(); }
+    CInPoint(CTransaction* ptxIn, unsigned int nIn) { ptx = ptxIn; n = nIn; }
+    void SetNull() { ptx = NULL; n = -1; }
+    bool IsNull() const { return (ptx == NULL && n == -1); }
+};
+
+
+
+
+class COutPoint
+{
+public:
+    uint256 hash;
+    unsigned int n;
+
+    COutPoint() { SetNull(); }
+    COutPoint(uint256 hashIn, unsigned int nIn) { hash = hashIn; n = nIn; }
+    IMPLEMENT_SERIALIZE( READWRITE(FLATDATA(*this)); )
+    void SetNull() { hash = 0; n = -1; }
+    bool IsNull() const { return (hash == 0 && n == -1); }
+
+    friend bool operator<(const COutPoint& a, const COutPoint& b)
+    {
+        return (a.hash < b.hash || (a.hash == b.hash && a.n < b.n));
+    }
+
+    friend bool operator==(const COutPoint& a, const COutPoint& b)
+    {
+        return (a.hash == b.hash && a.n == b.n);
+    }
+
+    friend bool operator!=(const COutPoint& a, const COutPoint& b)
+    {
+        return !(a == b);
+    }
+
+    string ToString() const
+    {
+        return strprintf("COutPoint(%s, %d)", hash.ToString().substr(0,6).c_str(), n);
+    }
+
+    void print() const
+    {
+        printf("%s\n", ToString().c_str());
+    }
+};
+
+
+
+
+//
+// An input of a transaction.  It contains the location of the previous
+// transaction's output that it claims and a signature that matches the
+// output's public key.
+//
+class CTxIn
+{
+public:
+    COutPoint prevout;
+    CScript scriptSig;
+    unsigned int nSequence;
+
+    CTxIn()
+    {
+        nSequence = UINT_MAX;
+    }
+
+    explicit CTxIn(COutPoint prevoutIn, CScript scriptSigIn=CScript(), unsigned int nSequenceIn=UINT_MAX)
+    {
+        prevout = prevoutIn;
+        scriptSig = scriptSigIn;
+        nSequence = nSequenceIn;
+    }
+
+    CTxIn(uint256 hashPrevTx, unsigned int nOut, CScript scriptSigIn=CScript(), unsigned int nSequenceIn=UINT_MAX)
+    {
+        prevout = COutPoint(hashPrevTx, nOut);
+        scriptSig = scriptSigIn;
+        nSequence = nSequenceIn;
+    }
+
+    IMPLEMENT_SERIALIZE
+    (
+        READWRITE(prevout);
+        READWRITE(scriptSig);
+        READWRITE(nSequence);
+    )
+
+    bool IsFinal() const
+    {
+        return (nSequence == UINT_MAX);
+    }
+
+    friend bool operator==(const CTxIn& a, const CTxIn& b)
+    {
+        return (a.prevout   == b.prevout &&
+                a.scriptSig == b.scriptSig &&
+                a.nSequence == b.nSequence);
+    }
+
+    friend bool operator!=(const CTxIn& a, const CTxIn& b)
+    {
+        return !(a == b);
+    }
+
+    string ToString() const
+    {
+        string str;
+        str += strprintf("CTxIn(");
+        str += prevout.ToString();
+        if (prevout.IsNull())
+            str += strprintf(", coinbase %s", HexStr(scriptSig.begin(), scriptSig.end(), false).c_str());
+        else
+            str += strprintf(", scriptSig=%s", scriptSig.ToString().substr(0,24).c_str());
+        if (nSequence != UINT_MAX)
+            str += strprintf(", nSequence=%u", nSequence);
+        str += ")";
+        return str;
+    }
+
+    void print() const
+    {
+        printf("%s\n", ToString().c_str());
+    }
+
+    bool IsMine() const;
+    int64 GetDebit() const;
+};
+
+
+
+
+//
+// An output of a transaction.  It contains the public key that the next input
+// must be able to sign with to claim it.
+//
+class CTxOut
+{
+public:
+    int64 nValue;
+    CScript scriptPubKey;
+
+public:
+    CTxOut()
+    {
+        SetNull();
+    }
+
+    CTxOut(int64 nValueIn, CScript scriptPubKeyIn)
+    {
+        nValue = nValueIn;
+        scriptPubKey = scriptPubKeyIn;
+    }
+
+    IMPLEMENT_SERIALIZE
+    (
+        READWRITE(nValue);
+        READWRITE(scriptPubKey);
+    )
+
+    void SetNull()
+    {
+        nValue = -1;
+        scriptPubKey.clear();
+    }
+
+    bool IsNull()
+    {
+        return (nValue == -1);
+    }
+
+    uint256 GetHash() const
+    {
+        return SerializeHash(*this);
+    }
+
+    bool IsMine() const
+    {
+        return ::IsMine(scriptPubKey);
+    }
+
+    int64 GetCredit() const
+    {
+        if (IsMine())
+            return nValue;
+        return 0;
+    }
+
+    friend bool operator==(const CTxOut& a, const CTxOut& b)
+    {
+        return (a.nValue       == b.nValue &&
+                a.scriptPubKey == b.scriptPubKey);
+    }
+
+    friend bool operator!=(const CTxOut& a, const CTxOut& b)
+    {
+        return !(a == b);
+    }
+
+    string ToString() const
+    {
+        if (scriptPubKey.size() < 6)
+            return "CTxOut(error)";
+        return strprintf("CTxOut(nValue=%I64d.%08I64d, scriptPubKey=%s)", nValue / COIN, nValue % COIN, scriptPubKey.ToString().substr(0,24).c_str());
+    }
+
+    void print() const
+    {
+        printf("%s\n", ToString().c_str());
+    }
+};
+
+
+
+
+//
+// The basic transaction that is broadcasted on the network and contained in
+// blocks.  A transaction can contain multiple inputs and outputs.
+//
+class CTransaction
+{
+public:
+    int nVersion;
+    vector<CTxIn> vin;
+    vector<CTxOut> vout;
+    int nLockTime;
+
+
+    CTransaction()
+    {
+        SetNull();
+    }
+
+    IMPLEMENT_SERIALIZE
+    (
+        READWRITE(this->nVersion);
+        nVersion = this->nVersion;
+        READWRITE(vin);
+        READWRITE(vout);
+        READWRITE(nLockTime);
+    )
+
+    void SetNull()
+    {
+        nVersion = 1;
+        vin.clear();
+        vout.clear();
+        nLockTime = 0;
+    }
+
+    bool IsNull() const
+    {
+        return (vin.empty() && vout.empty());
+    }
+
+    uint256 GetHash() const
+    {
+        return SerializeHash(*this);
+    }
+
+    bool IsFinal() const
+    {
+        if (nLockTime == 0 || nLockTime < nBestHeight)
+            return true;
+        foreach(const CTxIn& txin, vin)
+            if (!txin.IsFinal())
+                return false;
+        return true;
+    }
+
+    bool IsNewerThan(const CTransaction& old) const
+    {
+        if (vin.size() != old.vin.size())
+            return false;
+        for (int i = 0; i < vin.size(); i++)
+            if (vin[i].prevout != old.vin[i].prevout)
+                return false;
+
+        bool fNewer = false;
+        unsigned int nLowest = UINT_MAX;
+        for (int i = 0; i < vin.size(); i++)
+        {
+            if (vin[i].nSequence != old.vin[i].nSequence)
+            {
+                if (vin[i].nSequence <= nLowest)
+                {
+                    fNewer = false;
+                    nLowest = vin[i].nSequence;
+                }
+                if (old.vin[i].nSequence < nLowest)
+                {
+                    fNewer = true;
+                    nLowest = old.vin[i].nSequence;
+                }
+            }
+        }
+        return fNewer;
+    }
+
+    bool IsCoinBase() const
+    {
+        return (vin.size() == 1 && vin[0].prevout.IsNull());
+    }
+
+    bool CheckTransaction() const
+    {
+        // Basic checks that don't depend on any context
+        if (vin.empty() || vout.empty())
+            return error("CTransaction::CheckTransaction() : vin or vout empty");
+
+        // Check for negative values
+        foreach(const CTxOut& txout, vout)
+            if (txout.nValue < 0)
+                return error("CTransaction::CheckTransaction() : txout.nValue negative");
+
+        if (IsCoinBase())
+        {
+            if (vin[0].scriptSig.size() < 2 || vin[0].scriptSig.size() > 100)
+                return error("CTransaction::CheckTransaction() : coinbase script size");
+        }
+        else
+        {
+            foreach(const CTxIn& txin, vin)
+                if (txin.prevout.IsNull())
+                    return error("CTransaction::CheckTransaction() : prevout is null");
+        }
+
+        return true;
+    }
+
+    bool IsMine() const
+    {
+        foreach(const CTxOut& txout, vout)
+            if (txout.IsMine())
+                return true;
+        return false;
+    }
+
+    int64 GetDebit() const
+    {
+        int64 nDebit = 0;
+        foreach(const CTxIn& txin, vin)
+            nDebit += txin.GetDebit();
+        return nDebit;
+    }
+
+    int64 GetCredit() const
+    {
+        int64 nCredit = 0;
+        foreach(const CTxOut& txout, vout)
+            nCredit += txout.GetCredit();
+        return nCredit;
+    }
+
+    int64 GetValueOut() const
+    {
+        int64 nValueOut = 0;
+        foreach(const CTxOut& txout, vout)
+        {
+            if (txout.nValue < 0)
+                throw runtime_error("CTransaction::GetValueOut() : negative value");
+            nValueOut += txout.nValue;
+        }
+        return nValueOut;
+    }
+
+    int64 GetMinFee(bool fDiscount=false) const
+    {
+        // Base fee is 1 cent per kilobyte
+        unsigned int nBytes = ::GetSerializeSize(*this, SER_NETWORK);
+        int64 nMinFee = (1 + (int64)nBytes / 1000) * CENT;
+
+        // First 100 transactions in a block are free
+        if (fDiscount && nBytes < 10000)
+            nMinFee = 0;
+
+        // To limit dust spam, require a 0.01 fee if any output is less than 0.01
+        if (nMinFee < CENT)
+            foreach(const CTxOut& txout, vout)
+                if (txout.nValue < CENT)
+                    nMinFee = CENT;
+
+        return nMinFee;
+    }
+
+
+
+    bool ReadFromDisk(CDiskTxPos pos, FILE** pfileRet=NULL)
+    {
+        CAutoFile filein = OpenBlockFile(pos.nFile, 0, pfileRet ? "rb+" : "rb");
+        if (!filein)
+            return error("CTransaction::ReadFromDisk() : OpenBlockFile failed");
+
+        // Read transaction
+        if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)
+            return error("CTransaction::ReadFromDisk() : fseek failed");
+        filein >> *this;
+
+        // Return file pointer
+        if (pfileRet)
+        {
+            if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)
+                return error("CTransaction::ReadFromDisk() : second fseek failed");
+            *pfileRet = filein.release();
+        }
+        return true;
+    }
+
+
+    friend bool operator==(const CTransaction& a, const CTransaction& b)
+    {
+        return (a.nVersion  == b.nVersion &&
+                a.vin       == b.vin &&
+                a.vout      == b.vout &&
+                a.nLockTime == b.nLockTime);
+    }
+
+    friend bool operator!=(const CTransaction& a, const CTransaction& b)
+    {
+        return !(a == b);
+    }
+
+
+    string ToString() const
+    {
+        string str;
+        str += strprintf("CTransaction(hash=%s, ver=%d, vin.size=%d, vout.size=%d, nLockTime=%d)\n",
+            GetHash().ToString().substr(0,6).c_str(),
+            nVersion,
+            vin.size(),
+            vout.size(),
+            nLockTime);
+        for (int i = 0; i < vin.size(); i++)
+            str += "    " + vin[i].ToString() + "\n";
+        for (int i = 0; i < vout.size(); i++)
+            str += "    " + vout[i].ToString() + "\n";
+        return str;
+    }
+
+    void print() const
+    {
+        printf("%s", ToString().c_str());
+    }
+
+
+
+    bool DisconnectInputs(CTxDB& txdb);
+    bool ConnectInputs(CTxDB& txdb, map<uint256, CTxIndex>& mapTestPool, CDiskTxPos posThisTx, int nHeight, int64& nFees, bool fBlock, bool fMiner, int64 nMinFee=0);
+    bool ClientConnectInputs();
+
+    bool AcceptTransaction(CTxDB& txdb, bool fCheckInputs=true, bool* pfMissingInputs=NULL);
+
+    bool AcceptTransaction(bool fCheckInputs=true, bool* pfMissingInputs=NULL)
+    {
+        CTxDB txdb("r");
+        return AcceptTransaction(txdb, fCheckInputs, pfMissingInputs);
+    }
+
+protected:
+    bool AddToMemoryPool();
+public:
+    bool RemoveFromMemoryPool();
+};
+
+
+
+
+
+//
+// A transaction with a merkle branch linking it to the block chain
+//
+class CMerkleTx : public CTransaction
+{
+public:
+    uint256 hashBlock;
+    vector<uint256> vMerkleBranch;
+    int nIndex;
+
+    // memory only
+    mutable bool fMerkleVerified;
+
+
+    CMerkleTx()
+    {
+        Init();
+    }
+
+    CMerkleTx(const CTransaction& txIn) : CTransaction(txIn)
+    {
+        Init();
+    }
+
+    void Init()
+    {
+        hashBlock = 0;
+        nIndex = -1;
+        fMerkleVerified = false;
+    }
+
+    int64 GetCredit() const
+    {
+        // Must wait until coinbase is safely deep enough in the chain before valuing it
+        if (IsCoinBase() && GetBlocksToMaturity() > 0)
+            return 0;
+        return CTransaction::GetCredit();
+    }
+
+    IMPLEMENT_SERIALIZE
+    (
+        nSerSize += SerReadWrite(s, *(CTransaction*)this, nType, nVersion, ser_action);
+        nVersion = this->nVersion;
+        READWRITE(hashBlock);
+        READWRITE(vMerkleBranch);
+        READWRITE(nIndex);
+    )
+
+
+    int SetMerkleBranch(const CBlock* pblock=NULL);
+    int GetDepthInMainChain() const;
+    bool IsInMainChain() const { return GetDepthInMainChain() > 0; }
+    int GetBlocksToMaturity() const;
+    bool AcceptTransaction(CTxDB& txdb, bool fCheckInputs=true);
+    bool AcceptTransaction() { CTxDB txdb("r"); return AcceptTransaction(txdb); }
+};
+
+
+
+
+//
+// A transaction with a bunch of additional info that only the owner cares
+// about.  It includes any unrecorded transactions needed to link it back
+// to the block chain.
+//
+class CWalletTx : public CMerkleTx
+{
+public:
+    vector<CMerkleTx> vtxPrev;
+    map<string, string> mapValue;
+    vector<pair<string, string> > vOrderForm;
+    unsigned int fTimeReceivedIsTxTime;
+    unsigned int nTimeReceived;  // time received by this node
+    char fFromMe;
+    char fSpent;
+    //// probably need to sign the order info so know it came from payer
+
+    // memory only
+    mutable unsigned int nTimeDisplayed;
+
+
+    CWalletTx()
+    {
+        Init();
+    }
+
+    CWalletTx(const CMerkleTx& txIn) : CMerkleTx(txIn)
+    {
+        Init();
+    }
+
+    CWalletTx(const CTransaction& txIn) : CMerkleTx(txIn)
+    {
+        Init();
+    }
+
+    void Init()
+    {
+        fTimeReceivedIsTxTime = false;
+        nTimeReceived = 0;
+        fFromMe = false;
+        fSpent = false;
+        nTimeDisplayed = 0;
+    }
+
+    IMPLEMENT_SERIALIZE
+    (
+        nSerSize += SerReadWrite(s, *(CMerkleTx*)this, nType, nVersion, ser_action);
+        nVersion = this->nVersion;
+        READWRITE(vtxPrev);
+        READWRITE(mapValue);
+        READWRITE(vOrderForm);
+        READWRITE(fTimeReceivedIsTxTime);
+        READWRITE(nTimeReceived);
+        READWRITE(fFromMe);
+        READWRITE(fSpent);
+    )
+
+    bool WriteToDisk()
+    {
+        return CWalletDB().WriteTx(GetHash(), *this);
+    }
+
+
+    int64 GetTxTime() const;
+
+    void AddSupportingTransactions(CTxDB& txdb);
+
+    bool AcceptWalletTransaction(CTxDB& txdb, bool fCheckInputs=true);
+    bool AcceptWalletTransaction() { CTxDB txdb("r"); return AcceptWalletTransaction(txdb); }
+
+    void RelayWalletTransaction(CTxDB& txdb);
+    void RelayWalletTransaction() { CTxDB txdb("r"); RelayWalletTransaction(txdb); }
+};
+
+
+
+
+//
+// A txdb record that contains the disk location of a transaction and the
+// locations of transactions that spend its outputs.  vSpent is really only
+// used as a flag, but having the location is very helpful for debugging.
+//
+class CTxIndex
+{
+public:
+    CDiskTxPos pos;
+    vector<CDiskTxPos> vSpent;
+
+    CTxIndex()
+    {
+        SetNull();
+    }
+
+    CTxIndex(const CDiskTxPos& posIn, unsigned int nOutputs)
+    {
+        pos = posIn;
+        vSpent.resize(nOutputs);
+    }
+
+    IMPLEMENT_SERIALIZE
+    (
+        if (!(nType & SER_GETHASH))
+            READWRITE(nVersion);
+        READWRITE(pos);
+        READWRITE(vSpent);
+    )
+
+    void SetNull()
+    {
+        pos.SetNull();
+        vSpent.clear();
+    }
+
+    bool IsNull()
+    {
+        return pos.IsNull();
+    }
+
+    friend bool operator==(const CTxIndex& a, const CTxIndex& b)
+    {
+        if (a.pos != b.pos || a.vSpent.size() != b.vSpent.size())
+            return false;
+        for (int i = 0; i < a.vSpent.size(); i++)
+            if (a.vSpent[i] != b.vSpent[i])
+                return false;
+        return true;
+    }
+
+    friend bool operator!=(const CTxIndex& a, const CTxIndex& b)
+    {
+        return !(a == b);
+    }
+};
+
+
+
+
+
+//
+// Nodes collect new transactions into a block, hash them into a hash tree,
+// and scan through nonce values to make the block's hash satisfy proof-of-work
+// requirements.  When they solve the proof-of-work, they broadcast the block
+// to everyone and the block is added to the block chain.  The first transaction
+// in the block is a special one that creates a new coin owned by the creator
+// of the block.
+//
+// Blocks are appended to blk0001.dat files on disk.  Their location on disk
+// is indexed by CBlockIndex objects in memory.
+//
+class CBlock
+{
+public:
+    // header
+    int nVersion;
+    uint256 hashPrevBlock;
+    uint256 hashMerkleRoot;
+    unsigned int nTime;
+    unsigned int nBits;
+    unsigned int nNonce;
+
+    // network and disk
+    vector<CTransaction> vtx;
+
+    // memory only
+    mutable vector<uint256> vMerkleTree;
+
+
+    CBlock()
+    {
+        SetNull();
+    }
+
+    IMPLEMENT_SERIALIZE
+    (
+        READWRITE(this->nVersion);
+        nVersion = this->nVersion;
+        READWRITE(hashPrevBlock);
+        READWRITE(hashMerkleRoot);
+        READWRITE(nTime);
+        READWRITE(nBits);
+        READWRITE(nNonce);
+
+        // ConnectBlock depends on vtx being last so it can calculate offset
+        if (!(nType & (SER_GETHASH|SER_BLOCKHEADERONLY)))
+            READWRITE(vtx);
+        else if (fRead)
+            const_cast<CBlock*>(this)->vtx.clear();
+    )
+
+    void SetNull()
+    {
+        nVersion = 1;
+        hashPrevBlock = 0;
+        hashMerkleRoot = 0;
+        nTime = 0;
+        nBits = 0;
+        nNonce = 0;
+        vtx.clear();
+        vMerkleTree.clear();
+    }
+
+    bool IsNull() const
+    {
+        return (nBits == 0);
+    }
+
+    uint256 GetHash() const
+    {
+        return Hash(BEGIN(nVersion), END(nNonce));
+    }
+
+
+    uint256 BuildMerkleTree() const
+    {
+        vMerkleTree.clear();
+        foreach(const CTransaction& tx, vtx)
+            vMerkleTree.push_back(tx.GetHash());
+        int j = 0;
+        for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)
+        {
+            for (int i = 0; i < nSize; i += 2)
+            {
+                int i2 = min(i+1, nSize-1);
+                vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),
+                                           BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));
+            }
+            j += nSize;
+        }
+        return (vMerkleTree.empty() ? 0 : vMerkleTree.back());
+    }
+
+    vector<uint256> GetMerkleBranch(int nIndex) const
+    {
+        if (vMerkleTree.empty())
+            BuildMerkleTree();
+        vector<uint256> vMerkleBranch;
+        int j = 0;
+        for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)
+        {
+            int i = min(nIndex^1, nSize-1);
+            vMerkleBranch.push_back(vMerkleTree[j+i]);
+            nIndex >>= 1;
+            j += nSize;
+        }
+        return vMerkleBranch;
+    }
+
+    static uint256 CheckMerkleBranch(uint256 hash, const vector<uint256>& vMerkleBranch, int nIndex)
+    {
+        if (nIndex == -1)
+            return 0;
+        foreach(const uint256& otherside, vMerkleBranch)
+        {
+            if (nIndex & 1)
+                hash = Hash(BEGIN(otherside), END(otherside), BEGIN(hash), END(hash));
+            else
+                hash = Hash(BEGIN(hash), END(hash), BEGIN(otherside), END(otherside));
+            nIndex >>= 1;
+        }
+        return hash;
+    }
+
+
+    bool WriteToDisk(bool fWriteTransactions, unsigned int& nFileRet, unsigned int& nBlockPosRet)
+    {
+        // Open history file to append
+        CAutoFile fileout = AppendBlockFile(nFileRet);
+        if (!fileout)
+            return error("CBlock::WriteToDisk() : AppendBlockFile failed");
+        if (!fWriteTransactions)
+            fileout.nType |= SER_BLOCKHEADERONLY;
+
+        // Write index header
+        unsigned int nSize = fileout.GetSerializeSize(*this);
+        fileout << FLATDATA(pchMessageStart) << nSize;
+
+        // Write block
+        nBlockPosRet = ftell(fileout);
+        if (nBlockPosRet == -1)
+            return error("CBlock::WriteToDisk() : ftell failed");
+        fileout << *this;
+
+        return true;
+    }
+
+    bool ReadFromDisk(unsigned int nFile, unsigned int nBlockPos, bool fReadTransactions)
+    {
+        SetNull();
+
+        // Open history file to read
+        CAutoFile filein = OpenBlockFile(nFile, nBlockPos, "rb");
+        if (!filein)
+            return error("CBlock::ReadFromDisk() : OpenBlockFile failed");
+        if (!fReadTransactions)
+            filein.nType |= SER_BLOCKHEADERONLY;
+
+        // Read block
+        filein >> *this;
+
+        // Check the header
+        if (CBigNum().SetCompact(nBits) > bnProofOfWorkLimit)
+            return error("CBlock::ReadFromDisk() : nBits errors in block header");
+        if (GetHash() > CBigNum().SetCompact(nBits).getuint256())
+            return error("CBlock::ReadFromDisk() : GetHash() errors in block header");
+
+        return true;
+    }
+
+
+
+    void print() const
+    {
+        printf("CBlock(hash=%s, ver=%d, hashPrevBlock=%s, hashMerkleRoot=%s, nTime=%u, nBits=%08x, nNonce=%u, vtx=%d)\n",
+            GetHash().ToString().substr(0,14).c_str(),
+            nVersion,
+            hashPrevBlock.ToString().substr(0,14).c_str(),
+            hashMerkleRoot.ToString().substr(0,6).c_str(),
+            nTime, nBits, nNonce,
+            vtx.size());
+        for (int i = 0; i < vtx.size(); i++)
+        {
+            printf("  ");
+            vtx[i].print();
+        }
+        printf("  vMerkleTree: ");
+        for (int i = 0; i < vMerkleTree.size(); i++)
+            printf("%s ", vMerkleTree[i].ToString().substr(0,6).c_str());
+        printf("\n");
+    }
+
+
+    int64 GetBlockValue(int64 nFees) const;
+    bool DisconnectBlock(CTxDB& txdb, CBlockIndex* pindex);
+    bool ConnectBlock(CTxDB& txdb, CBlockIndex* pindex);
+    bool ReadFromDisk(const CBlockIndex* blockindex, bool fReadTransactions);
+    bool AddToBlockIndex(unsigned int nFile, unsigned int nBlockPos);
+    bool CheckBlock() const;
+    bool AcceptBlock();
+};
+
+
+
+
+
+
+//
+// The block chain is a tree shaped structure starting with the
+// genesis block at the root, with each block potentially having multiple
+// candidates to be the next block.  pprev and pnext link a path through the
+// main/longest chain.  A blockindex may have multiple pprev pointing back
+// to it, but pnext will only point forward to the longest branch, or will
+// be null if the block is not part of the longest chain.
+//
+class CBlockIndex
+{
+public:
+    const uint256* phashBlock;
+    CBlockIndex* pprev;
+    CBlockIndex* pnext;
+    unsigned int nFile;
+    unsigned int nBlockPos;
+    int nHeight;
+
+    // block header
+    int nVersion;
+    uint256 hashMerkleRoot;
+    unsigned int nTime;
+    unsigned int nBits;
+    unsigned int nNonce;
+
+
+    CBlockIndex()
+    {
+        phashBlock = NULL;
+        pprev = NULL;
+        pnext = NULL;
+        nFile = 0;
+        nBlockPos = 0;
+        nHeight = 0;
+
+        nVersion       = 0;
+        hashMerkleRoot = 0;
+        nTime          = 0;
+        nBits          = 0;
+        nNonce         = 0;
+    }
+
+    CBlockIndex(unsigned int nFileIn, unsigned int nBlockPosIn, CBlock& block)
+    {
+        phashBlock = NULL;
+        pprev = NULL;
+        pnext = NULL;
+        nFile = nFileIn;
+        nBlockPos = nBlockPosIn;
+        nHeight = 0;
+
+        nVersion       = block.nVersion;
+        hashMerkleRoot = block.hashMerkleRoot;
+        nTime          = block.nTime;
+        nBits          = block.nBits;
+        nNonce         = block.nNonce;
+    }
+
+    uint256 GetBlockHash() const
+    {
+        return *phashBlock;
+    }
+
+    bool IsInMainChain() const
+    {
+        return (pnext || this == pindexBest);
+    }
+
+    bool EraseBlockFromDisk()
+    {
+        // Open history file
+        CAutoFile fileout = OpenBlockFile(nFile, nBlockPos, "rb+");
+        if (!fileout)
+            return false;
+
+        // Overwrite with empty null block
+        CBlock block;
+        block.SetNull();
+        fileout << block;
+
+        return true;
+    }
+
+    enum { nMedianTimeSpan=11 };
+
+    int64 GetMedianTimePast() const
+    {
+        unsigned int pmedian[nMedianTimeSpan];
+        unsigned int* pbegin = &pmedian[nMedianTimeSpan];
+        unsigned int* pend = &pmedian[nMedianTimeSpan];
+
+        const CBlockIndex* pindex = this;
+        for (int i = 0; i < nMedianTimeSpan && pindex; i++, pindex = pindex->pprev)
+            *(--pbegin) = pindex->nTime;
+
+        sort(pbegin, pend);
+        return pbegin[(pend - pbegin)/2];
+    }
+
+    int64 GetMedianTime() const
+    {
+        const CBlockIndex* pindex = this;
+        for (int i = 0; i < nMedianTimeSpan/2; i++)
+        {
+            if (!pindex->pnext)
+                return nTime;
+            pindex = pindex->pnext;
+        }
+        return pindex->GetMedianTimePast();
+    }
+
+
+
+    string ToString() const
+    {
+        return strprintf("CBlockIndex(nprev=%08x, pnext=%08x, nFile=%d, nBlockPos=%-6d nHeight=%d, merkle=%s, hashBlock=%s)",
+            pprev, pnext, nFile, nBlockPos, nHeight,
+            hashMerkleRoot.ToString().substr(0,6).c_str(),
+            GetBlockHash().ToString().substr(0,14).c_str());
+    }
+
+    void print() const
+    {
+        printf("%s\n", ToString().c_str());
+    }
+};
+
+
+
+//
+// Used to marshal pointers into hashes for db storage.
+//
+class CDiskBlockIndex : public CBlockIndex
+{
+public:
+    uint256 hashPrev;
+    uint256 hashNext;
+
+    CDiskBlockIndex()
+    {
+        hashPrev = 0;
+        hashNext = 0;
+    }
+
+    explicit CDiskBlockIndex(CBlockIndex* pindex) : CBlockIndex(*pindex)
+    {
+        hashPrev = (pprev ? pprev->GetBlockHash() : 0);
+        hashNext = (pnext ? pnext->GetBlockHash() : 0);
+    }
+
+    IMPLEMENT_SERIALIZE
+    (
+        if (!(nType & SER_GETHASH))
+            READWRITE(nVersion);
+
+        READWRITE(hashNext);
+        READWRITE(nFile);
+        READWRITE(nBlockPos);
+        READWRITE(nHeight);
+
+        // block header
+        READWRITE(this->nVersion);
+        READWRITE(hashPrev);
+        READWRITE(hashMerkleRoot);
+        READWRITE(nTime);
+        READWRITE(nBits);
+        READWRITE(nNonce);
+    )
+
+    uint256 GetBlockHash() const
+    {
+        CBlock block;
+        block.nVersion        = nVersion;
+        block.hashPrevBlock   = hashPrev;
+        block.hashMerkleRoot  = hashMerkleRoot;
+        block.nTime           = nTime;
+        block.nBits           = nBits;
+        block.nNonce          = nNonce;
+        return block.GetHash();
+    }
+
+
+    string ToString() const
+    {
+        string str = "CDiskBlockIndex(";
+        str += CBlockIndex::ToString();
+        str += strprintf("\n                hashBlock=%s, hashPrev=%s, hashNext=%s)",
+            GetBlockHash().ToString().c_str(),
+            hashPrev.ToString().substr(0,14).c_str(),
+            hashNext.ToString().substr(0,14).c_str());
+        return str;
+    }
+
+    void print() const
+    {
+        printf("%s\n", ToString().c_str());
+    }
+};
+
+
+
+
+
+
+
+
+//
+// Describes a place in the block chain to another node such that if the
+// other node doesn't have the same branch, it can find a recent common trunk.
+// The further back it is, the further before the fork it may be.
+//
+class CBlockLocator
+{
+protected:
+    vector<uint256> vHave;
+public:
+
+    CBlockLocator()
+    {
+    }
+
+    explicit CBlockLocator(const CBlockIndex* pindex)
+    {
+        Set(pindex);
+    }
+
+    explicit CBlockLocator(uint256 hashBlock)
+    {
+        map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);
+        if (mi != mapBlockIndex.end())
+            Set((*mi).second);
+    }
+
+    IMPLEMENT_SERIALIZE
+    (
+        if (!(nType & SER_GETHASH))
+            READWRITE(nVersion);
+        READWRITE(vHave);
+    )
+
+    void Set(const CBlockIndex* pindex)
+    {
+        vHave.clear();
+        int nStep = 1;
+        while (pindex)
+        {
+            vHave.push_back(pindex->GetBlockHash());
+
+            // Exponentially larger steps back
+            for (int i = 0; pindex && i < nStep; i++)
+                pindex = pindex->pprev;
+            if (vHave.size() > 10)
+                nStep *= 2;
+        }
+        vHave.push_back(hashGenesisBlock);
+    }
+
+    CBlockIndex* GetBlockIndex()
+    {
+        // Find the first block the caller has in the main chain
+        foreach(const uint256& hash, vHave)
+        {
+            map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);
+            if (mi != mapBlockIndex.end())
+            {
+                CBlockIndex* pindex = (*mi).second;
+                if (pindex->IsInMainChain())
+                    return pindex;
+            }
+        }
+        return pindexGenesisBlock;
+    }
+
+    uint256 GetBlockHash()
+    {
+        // Find the first block the caller has in the main chain
+        foreach(const uint256& hash, vHave)
+        {
+            map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);
+            if (mi != mapBlockIndex.end())
+            {
+                CBlockIndex* pindex = (*mi).second;
+                if (pindex->IsInMainChain())
+                    return hash;
+            }
+        }
+        return hashGenesisBlock;
+    }
+
+    int GetHeight()
+    {
+        CBlockIndex* pindex = GetBlockIndex();
+        if (!pindex)
+            return 0;
+        return pindex->nHeight;
+    }
+};
+
+
+
+
+
+
+
+
+
+
+
+
+extern map<uint256, CTransaction> mapTransactions;
+extern map<uint256, CWalletTx> mapWallet;
+extern vector<pair<uint256, bool> > vWalletUpdated;
+extern CCriticalSection cs_mapWallet;
+extern map<vector<unsigned char>, CPrivKey> mapKeys;
+extern map<uint160, vector<unsigned char> > mapPubKeys;
+extern CCriticalSection cs_mapKeys;
+extern CKey keyUser;
/trunk/makefile Diff Switch to side-by-side view
--- a
+++ b/trunk/makefile
@@ -0,0 +1,83 @@
+# Copyright (c) 2009 Satoshi Nakamoto
+# Distributed under the MIT/X11 software license, see the accompanying
+# file license.txt or http://www.opensource.org/licenses/mit-license.php.
+
+
+ifneq "$(BUILD)" "debug"
+ifneq "$(BUILD)" "release"
+BUILD=debug
+endif
+endif
+ifeq "$(BUILD)" "debug"
+D=d
+# note: gcc 3.x profile doesn't work
+#DEBUGFLAGS=-O0 -g -pg -D__WXDEBUG__
+DEBUGFLAGS=-g -D__WXDEBUG__
+endif
+
+
+
+INCLUDEPATHS=-I"/boost" -I"/DB/build_unix" -I"/OpenSSL/include" -I"/wxWidgets/lib/vc_lib/mswd" -I"/wxWidgets/include"
+LIBPATHS=-L"/DB/build_unix" -L"/OpenSSL/out" -L"/wxWidgets/lib/gcc_lib"
+LIBS= \
+ -l db_cxx \
+ -l eay32 \
+ -l wxmsw28$(D)_richtext -l wxmsw28$(D)_html -l wxmsw28$(D)_core -l wxbase28$(D) -l wxtiff$(D) -l wxjpeg$(D) -l wxpng$(D) -l wxzlib$(D) -l wxregex$(D) -l wxexpat$(D) \
+ -l kernel32 -l user32 -l gdi32 -l comdlg32 -l winspool -l winmm -l shell32 -l comctl32 -l ole32 -l oleaut32 -l uuid -l rpcrt4 -l advapi32 -l ws2_32
+WXDEFS=-DWIN32 -D__WXMSW__ -D_WINDOWS -DNOPCH
+CFLAGS=-mthreads -O0 -w -Wno-invalid-offsetof -Wformat $(DEBUGFLAGS) $(WXDEFS) $(INCLUDEPATHS)
+HEADERS=headers.h util.h main.h serialize.h uint256.h key.h bignum.h script.h db.h base58.h
+
+
+
+all: bitcoin.exe
+
+
+headers.h.gch: headers.h $(HEADERS) net.h irc.h market.h uibase.h ui.h
+	g++ -c $(CFLAGS) -o $@ $<
+
+obj/util.o: util.cpp		    $(HEADERS)
+	g++ -c $(CFLAGS) -o $@ $<
+
+obj/script.o: script.cpp	    $(HEADERS)
+	g++ -c $(CFLAGS) -o $@ $<
+
+obj/db.o: db.cpp		    $(HEADERS) market.h
+	g++ -c $(CFLAGS) -o $@ $<
+
+obj/net.o: net.cpp		    $(HEADERS) net.h
+	g++ -c $(CFLAGS) -o $@ $<
+
+obj/main.o: main.cpp		    $(HEADERS) net.h market.h sha.h
+	g++ -c $(CFLAGS) -o $@ $<
+
+obj/market.o: market.cpp	    $(HEADERS) market.h
+	g++ -c $(CFLAGS) -o $@ $<
+
+obj/ui.o: ui.cpp		    $(HEADERS) net.h uibase.h ui.h market.h
+	g++ -c $(CFLAGS) -o $@ $<
+
+obj/uibase.o: uibase.cpp	    uibase.h
+	g++ -c $(CFLAGS) -o $@ $<
+
+obj/sha.o: sha.cpp		    sha.h
+	g++ -c $(CFLAGS) -O3 -o $@ $<
+
+obj/irc.o:  irc.cpp		    $(HEADERS)
+	g++ -c $(CFLAGS) -o $@ $<
+
+obj/ui_res.o: ui.rc  rc/bitcoin.ico rc/check.ico rc/send16.bmp rc/send16mask.bmp rc/send16masknoshadow.bmp rc/send20.bmp rc/send20mask.bmp rc/addressbook16.bmp rc/addressbook16mask.bmp rc/addressbook20.bmp rc/addressbook20mask.bmp
+	windres $(WXDEFS) $(INCLUDEPATHS) -o $@ -i $<
+
+
+
+OBJS=obj/util.o obj/script.o obj/db.o obj/net.o obj/main.o obj/market.o	 \
+	obj/ui.o obj/uibase.o obj/sha.o obj/irc.o obj/ui_res.o
+
+bitcoin.exe: headers.h.gch $(OBJS)
+	-kill /f bitcoin.exe
+	g++ $(CFLAGS) -mwindows -Wl,--subsystem,windows -o $@ $(LIBPATHS) $(OBJS) $(LIBS)
+
+clean:
+	-del /Q obj\*
+	-del /Q headers.h.gch
/trunk/makefile.vc Diff Switch to side-by-side view
--- a
+++ b/trunk/makefile.vc
@@ -0,0 +1,77 @@
+# Copyright (c) 2009 Satoshi Nakamoto
+# Distributed under the MIT/X11 software license, see the accompanying
+# file license.txt or http://www.opensource.org/licenses/mit-license.php.
+
+
+!IF "$(BUILD)" != "debug" && "$(BUILD)" != "release"
+BUILD=debug
+!ENDIF
+!IF "$(BUILD)" == "debug"
+D=d
+DEBUGFLAGS=/Zi /Od /D__WXDEBUG__
+!ENDIF
+
+
+
+INCLUDEPATHS=/I"/boost" /I"/DB/build_windows" /I"/OpenSSL/include" /I"/wxWidgets/lib/vc_lib/mswd" /I"/wxWidgets/include"
+LIBPATHS=/LIBPATH:"/DB/build_windows/$(BUILD)" /LIBPATH:"/OpenSSL/out" /LIBPATH:"/wxWidgets/lib/vc_lib"
+LIBS= \
+    libdb47s$(D).lib \
+    libeay32.lib \
+    wxmsw28$(D)_richtext.lib wxmsw28$(D)_html.lib wxmsw28$(D)_core.lib wxbase28$(D).lib wxtiff$(D).lib wxjpeg$(D).lib wxpng$(D).lib wxzlib$(D).lib wxregex$(D).lib wxexpat$(D).lib \
+    kernel32.lib user32.lib gdi32.lib comdlg32.lib winspool.lib winmm.lib shell32.lib comctl32.lib ole32.lib oleaut32.lib uuid.lib rpcrt4.lib advapi32.lib ws2_32.lib
+WXDEFS=/DWIN32 /D__WXMSW__ /D_WINDOWS /DNOPCH
+CFLAGS=/c /nologo /Ob0 /MD$(D) /EHsc /GR /Zm300 /YX /Fpobj/headers.pch $(DEBUGFLAGS) $(WXDEFS) $(INCLUDEPATHS)
+HEADERS=headers.h util.h main.h serialize.h uint256.h key.h bignum.h script.h db.h base58.h
+
+
+
+all: bitcoin.exe
+
+
+obj\util.obj: util.cpp        $(HEADERS)
+    cl $(CFLAGS) /Fo$@ %s
+
+obj\script.obj: script.cpp    $(HEADERS)
+    cl $(CFLAGS) /Fo$@ %s
+
+obj\db.obj: db.cpp            $(HEADERS) market.h
+    cl $(CFLAGS) /Fo$@ %s
+
+obj\net.obj: net.cpp          $(HEADERS) net.h
+    cl $(CFLAGS) /Fo$@ %s
+
+obj\main.obj: main.cpp        $(HEADERS) net.h market.h
+    cl $(CFLAGS) /Fo$@ %s
+
+obj\market.obj: market.cpp    $(HEADERS) market.h
+    cl $(CFLAGS) /Fo$@ %s
+
+obj\ui.obj: ui.cpp            $(HEADERS) net.h uibase.h ui.h market.h
+    cl $(CFLAGS) /Fo$@ %s
+
+obj\uibase.obj: uibase.cpp    uibase.h
+    cl $(CFLAGS) /Fo$@ %s
+
+obj\sha.obj: sha.cpp sha.h
+    cl $(CFLAGS) /O2 /Fo$@ %s
+
+obj\irc.obj:  irc.cpp         $(HEADERS)
+    cl $(CFLAGS) /Fo$@ %s
+
+obj\ui.res: ui.rc  rc/bitcoin.ico rc/check.ico rc/send16.bmp rc/send16mask.bmp rc/send16masknoshadow.bmp rc/send20.bmp rc/send20mask.bmp rc/addressbook16.bmp rc/addressbook16mask.bmp rc/addressbook20.bmp rc/addressbook20mask.bmp
+    rc $(INCLUDEPATHS) $(WXDEFS) /Fo$@ %s
+
+
+
+OBJS=obj\util.obj obj\script.obj obj\db.obj obj\net.obj obj\main.obj obj\market.obj \
+  obj\ui.obj obj\uibase.obj obj\sha.obj obj\irc.obj obj\ui.res
+
+bitcoin.exe: $(OBJS)
+    -kill /f bitcoin.exe & sleep 1
+    link /nologo /DEBUG /SUBSYSTEM:WINDOWS /OUT:$@ $(LIBPATHS) $** $(LIBS)
+
+clean:
+    -del /Q obj\*
+    -del *.ilk
+    -del *.pdb
/trunk/market.cpp Diff Switch to side-by-side view
--- a
+++ b/trunk/market.cpp
@@ -0,0 +1,264 @@
+// Copyright (c) 2009 Satoshi Nakamoto
+// Distributed under the MIT/X11 software license, see the accompanying
+// file license.txt or http://www.opensource.org/licenses/mit-license.php.
+
+#include "headers.h"
+
+
+
+
+
+
+
+
+
+
+//
+// Global state variables
+//
+
+//// later figure out how these are persisted
+map<uint256, CProduct> mapMyProducts;
+
+
+
+
+map<uint256, CProduct> mapProducts;
+CCriticalSection cs_mapProducts;
+
+bool AdvertInsert(const CProduct& product)
+{
+    uint256 hash = product.GetHash();
+    bool fNew = false;
+    bool fUpdated = false;
+
+    CRITICAL_BLOCK(cs_mapProducts)
+    {
+        // Insert or find existing product
+        pair<map<uint256, CProduct>::iterator, bool> item = mapProducts.insert(make_pair(hash, product));
+        CProduct* pproduct = &(*(item.first)).second;
+        fNew = item.second;
+
+        // Update if newer
+        if (product.nSequence > pproduct->nSequence)
+        {
+            *pproduct = product;
+            fUpdated = true;
+        }
+    }
+
+    //if (fNew)
+    //    NotifyProductAdded(hash);
+    //else if (fUpdated)
+    //    NotifyProductUpdated(hash);
+
+    return (fNew || fUpdated);
+}
+
+void AdvertErase(const CProduct& product)
+{
+    uint256 hash = product.GetHash();
+    CRITICAL_BLOCK(cs_mapProducts)
+        mapProducts.erase(hash);
+    //NotifyProductDeleted(hash);
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+template<typename T>
+unsigned int Union(T& v1, T& v2)
+{
+    // v1 = v1 union v2
+    // v1 and v2 must be sorted
+    // returns the number of elements added to v1
+
+    ///// need to check that this is equivalent, then delete this comment
+    //vector<unsigned short> vUnion(v1.size() + v2.size());
+    //vUnion.erase(set_union(v1.begin(), v1.end(),
+    //                       v2.begin(), v2.end(),
+    //                       vUnion.begin()),
+    //             vUnion.end());
+
+    T vUnion;
+    vUnion.reserve(v1.size() + v2.size());
+    set_union(v1.begin(), v1.end(),
+              v2.begin(), v2.end(),
+              back_inserter(vUnion));
+    unsigned int nAdded = vUnion.size() - v1.size();
+    if (nAdded > 0)
+        v1 = vUnion;
+    return nAdded;
+}
+
+void CUser::AddAtom(unsigned short nAtom, bool fOrigin)
+{
+    // Ignore duplicates
+    if (binary_search(vAtomsIn.begin(), vAtomsIn.end(), nAtom) ||
+        find(vAtomsNew.begin(), vAtomsNew.end(), nAtom) != vAtomsNew.end())
+        return;
+
+    //// instead of zero atom, should change to free atom that propagates,
+    //// limited to lower than a certain value like 5 so conflicts quickly
+    // The zero atom never propagates,
+    // new atoms always propagate through the user that created them
+    if (nAtom == 0 || fOrigin)
+    {
+        vector<unsigned short> vTmp(1, nAtom);
+        Union(vAtomsIn, vTmp);
+        if (fOrigin)
+            vAtomsOut.push_back(nAtom);
+        return;
+    }
+
+    vAtomsNew.push_back(nAtom);
+
+    if (vAtomsNew.size() >= nFlowthroughRate || vAtomsOut.empty())
+    {
+        // Select atom to flow through to vAtomsOut
+        vAtomsOut.push_back(vAtomsNew[GetRand(vAtomsNew.size())]);
+
+        // Merge vAtomsNew into vAtomsIn
+        sort(vAtomsNew.begin(), vAtomsNew.end());
+        Union(vAtomsIn, vAtomsNew);
+        vAtomsNew.clear();
+    }
+}
+
+bool AddAtomsAndPropagate(uint256 hashUserStart, const vector<unsigned short>& vAtoms, bool fOrigin)
+{
+    CReviewDB reviewdb;
+    map<uint256, vector<unsigned short> > pmapPropagate[2];
+    pmapPropagate[0][hashUserStart] = vAtoms;
+
+    for (int side = 0; !pmapPropagate[side].empty(); side = 1 - side)
+    {
+        map<uint256, vector<unsigned short> >& mapFrom = pmapPropagate[side];
+        map<uint256, vector<unsigned short> >& mapTo = pmapPropagate[1 - side];
+
+        for (map<uint256, vector<unsigned short> >::iterator mi = mapFrom.begin(); mi != mapFrom.end(); ++mi)
+        {
+            const uint256& hashUser = (*mi).first;
+            const vector<unsigned short>& vReceived = (*mi).second;
+
+            ///// this would be a lot easier on the database if it put the new atom at the beginning of the list,
+            ///// so the change would be right next to the vector size.
+
+            // Read user
+            CUser user;
+            reviewdb.ReadUser(hashUser, user);
+            unsigned int nIn = user.vAtomsIn.size();
+            unsigned int nNew = user.vAtomsNew.size();
+            unsigned int nOut = user.vAtomsOut.size();
+
+            // Add atoms received
+            foreach(unsigned short nAtom, vReceived)
+                user.AddAtom(nAtom, fOrigin);
+            fOrigin = false;
+
+            // Don't bother writing to disk if no changes
+            if (user.vAtomsIn.size() == nIn && user.vAtomsNew.size() == nNew)
+                continue;
+
+            // Propagate
+            if (user.vAtomsOut.size() > nOut)
+                foreach(const uint256& hash, user.vLinksOut)
+                    mapTo[hash].insert(mapTo[hash].end(), user.vAtomsOut.begin() + nOut, user.vAtomsOut.end());
+
+            // Write back
+            if (!reviewdb.WriteUser(hashUser, user))
+                return false;
+        }
+        mapFrom.clear();
+    }
+    return true;
+}
+
+
+
+
+
+
+bool CReview::AcceptReview()
+{
+    // Timestamp
+    nTime = GetTime();
+
+    // Check signature
+    if (!CKey::Verify(vchPubKeyFrom, GetSigHash(), vchSig))
+        return false;
+
+    CReviewDB reviewdb;
+
+    // Add review text to recipient
+    vector<CReview> vReviews;
+    reviewdb.ReadReviews(hashTo, vReviews);
+    vReviews.push_back(*this);
+    if (!reviewdb.WriteReviews(hashTo, vReviews))
+        return false;
+
+    // Add link from sender
+    CUser user;
+    uint256 hashFrom = Hash(vchPubKeyFrom.begin(), vchPubKeyFrom.end());
+    reviewdb.ReadUser(hashFrom, user);
+    user.vLinksOut.push_back(hashTo);
+    if (!reviewdb.WriteUser(hashFrom, user))
+        return false;
+
+    reviewdb.Close();
+
+    // Propagate atoms to recipient
+    vector<unsigned short> vZeroAtom(1, 0);
+    if (!AddAtomsAndPropagate(hashTo, user.vAtomsOut.size() ? user.vAtomsOut : vZeroAtom, false))
+        return false;
+
+    return true;
+}
+
+
+
+
+
+bool CProduct::CheckSignature()
+{
+    return (CKey::Verify(vchPubKeyFrom, GetSigHash(), vchSig));
+}
+
+bool CProduct::CheckProduct()
+{
+    if (!CheckSignature())
+        return false;
+
+    // Make sure it's a summary product
+    if (!mapDetails.empty() || !vOrderForm.empty())
+        return false;
+
+    // Look up seller's atom count
+    CReviewDB reviewdb("r");
+    CUser user;
+    reviewdb.ReadUser(GetUserHash(), user);
+    nAtoms = user.GetAtomCount();
+    reviewdb.Close();
+
+    ////// delme, this is now done by AdvertInsert
+    //// Store to memory
+    //CRITICAL_BLOCK(cs_mapProducts)
+    //    mapProducts[GetHash()] = *this;
+
+    return true;
+}
/trunk/market.h Diff Switch to side-by-side view
--- a
+++ b/trunk/market.h
@@ -0,0 +1,182 @@
+// Copyright (c) 2009 Satoshi Nakamoto
+// Distributed under the MIT/X11 software license, see the accompanying
+// file license.txt or http://www.opensource.org/licenses/mit-license.php.
+
+class CUser;
+class CReview;
+class CProduct;
+
+static const unsigned int nFlowthroughRate = 2;
+
+
+
+
+bool AdvertInsert(const CProduct& product);
+void AdvertErase(const CProduct& product);
+bool AddAtomsAndPropagate(uint256 hashUserStart, const vector<unsigned short>& vAtoms, bool fOrigin);
+
+
+
+
+
+
+
+
+class CUser
+{
+public:
+    vector<unsigned short> vAtomsIn;
+    vector<unsigned short> vAtomsNew;
+    vector<unsigned short> vAtomsOut;
+    vector<uint256> vLinksOut;
+
+    CUser()
+    {
+    }
+
+    IMPLEMENT_SERIALIZE
+    (
+        if (!(nType & SER_GETHASH))
+            READWRITE(nVersion);
+        READWRITE(vAtomsIn);
+        READWRITE(vAtomsNew);
+        READWRITE(vAtomsOut);
+        READWRITE(vLinksOut);
+    )
+
+    void SetNull()
+    {
+        vAtomsIn.clear();
+        vAtomsNew.clear();
+        vAtomsOut.clear();
+        vLinksOut.clear();
+    }
+
+    uint256 GetHash() const { return SerializeHash(*this); }
+
+
+    int GetAtomCount() const
+    {
+        return (vAtomsIn.size() + vAtomsNew.size());
+    }
+
+    void AddAtom(unsigned short nAtom, bool fOrigin);
+};
+
+
+
+
+
+
+
+class CReview
+{
+public:
+    int nVersion;
+    uint256 hashTo;
+    map<string, string> mapValue;
+    vector<unsigned char> vchPubKeyFrom;
+    vector<unsigned char> vchSig;
+
+    // memory only
+    unsigned int nTime;
+    int nAtoms;
+
+
+    CReview()
+    {
+        nVersion = 1;
+        hashTo = 0;
+        nTime = 0;
+        nAtoms = 0;
+    }
+
+    IMPLEMENT_SERIALIZE
+    (
+        READWRITE(this->nVersion);
+        nVersion = this->nVersion;
+        if (!(nType & SER_DISK))
+            READWRITE(hashTo);
+        READWRITE(mapValue);
+        READWRITE(vchPubKeyFrom);
+        if (!(nType & SER_GETHASH))
+            READWRITE(vchSig);
+    )
+
+    uint256 GetHash() const { return SerializeHash(*this); }
+    uint256 GetSigHash() const { return SerializeHash(*this, SER_GETHASH|SER_SKIPSIG); }
+    uint256 GetUserHash() const { return Hash(vchPubKeyFrom.begin(), vchPubKeyFrom.end()); }
+
+
+    bool AcceptReview();
+};
+
+
+
+
+
+
+
+class CProduct
+{
+public:
+    int nVersion;
+    CAddress addr;
+    map<string, string> mapValue;
+    map<string, string> mapDetails;
+    vector<pair<string, string> > vOrderForm;
+    unsigned int nSequence;
+    vector<unsigned char> vchPubKeyFrom;
+    vector<unsigned char> vchSig;
+
+    // disk only
+    int nAtoms;
+
+    // memory only
+    set<unsigned int> setSources;
+
+    CProduct()
+    {
+        nVersion = 1;
+        nAtoms = 0;
+        nSequence = 0;
+    }
+
+    IMPLEMENT_SERIALIZE
+    (
+        READWRITE(this->nVersion);
+        nVersion = this->nVersion;
+        READWRITE(addr);
+        READWRITE(mapValue);
+        if (!(nType & SER_GETHASH))
+        {
+            READWRITE(mapDetails);
+            READWRITE(vOrderForm);
+            READWRITE(nSequence);
+        }
+        READWRITE(vchPubKeyFrom);
+        if (!(nType & SER_GETHASH))
+            READWRITE(vchSig);
+        if (nType & SER_DISK)
+            READWRITE(nAtoms);
+    )
+
+    uint256 GetHash() const { return SerializeHash(*this); }
+    uint256 GetSigHash() const { return SerializeHash(*this, SER_GETHASH|SER_SKIPSIG); }
+    uint256 GetUserHash() const { return Hash(vchPubKeyFrom.begin(), vchPubKeyFrom.end()); }
+
+
+    bool CheckSignature();
+    bool CheckProduct();
+};
+
+
+
+
+
+
+
+
+extern map<uint256, CProduct> mapProducts;
+extern CCriticalSection cs_mapProducts;
+extern map<uint256, CProduct> mapMyProducts;
/trunk/mingwm10.dll
Binary file was added.
/trunk/net.cpp Diff Switch to side-by-side view
--- a
+++ b/trunk/net.cpp
@@ -0,0 +1,1100 @@
+// Copyright (c) 2009 Satoshi Nakamoto
+// Distributed under the MIT/X11 software license, see the accompanying
+// file license.txt or http://www.opensource.org/licenses/mit-license.php.
+
+#include "headers.h"
+#include <winsock2.h>
+
+void ThreadMessageHandler2(void* parg);
+void ThreadSocketHandler2(void* parg);
+void ThreadOpenConnections2(void* parg);
+
+
+
+
+
+
+//
+// Global state variables
+//
+bool fClient = false;
+uint64 nLocalServices = (fClient ? 0 : NODE_NETWORK);
+CAddress addrLocalHost(0, DEFAULT_PORT, nLocalServices);
+CNode nodeLocalHost(INVALID_SOCKET, CAddress("127.0.0.1", nLocalServices));
+CNode* pnodeLocalHost = &nodeLocalHost;
+bool fShutdown = false;
+array<bool, 10> vfThreadRunning;
+vector<CNode*> vNodes;
+CCriticalSection cs_vNodes;
+map<vector<unsigned char>, CAddress> mapAddresses;
+CCriticalSection cs_mapAddresses;
+map<CInv, CDataStream> mapRelay;
+deque<pair<int64, CInv> > vRelayExpiration;
+CCriticalSection cs_mapRelay;
+map<CInv, int64> mapAlreadyAskedFor;
+
+
+
+CAddress addrProxy;
+
+bool ConnectSocket(const CAddress& addrConnect, SOCKET& hSocketRet)
+{
+    hSocketRet = INVALID_SOCKET;
+
+    SOCKET hSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
+    if (hSocket == INVALID_SOCKET)
+        return false;
+
+    bool fRoutable = !(addrConnect.GetByte(3) == 10 || (addrConnect.GetByte(3) == 192 && addrConnect.GetByte(2) == 168));
+    bool fProxy = (addrProxy.ip && fRoutable);
+    struct sockaddr_in sockaddr = (fProxy ? addrProxy.GetSockAddr() : addrConnect.GetSockAddr());
+
+    if (connect(hSocket, (struct sockaddr*)&sockaddr, sizeof(sockaddr)) == SOCKET_ERROR)
+    {
+        closesocket(hSocket);
+        return false;
+    }
+
+    if (fProxy)
+    {
+        printf("Proxy connecting to %s\n", addrConnect.ToString().c_str());
+        char pszSocks4IP[] = "\4\1\0\0\0\0\0\0user";
+        memcpy(pszSocks4IP + 2, &addrConnect.port, 2);
+        memcpy(pszSocks4IP + 4, &addrConnect.ip, 4);
+        char* pszSocks4 = pszSocks4IP;
+        int nSize = sizeof(pszSocks4IP);
+
+        int ret = send(hSocket, pszSocks4, nSize, 0);
+        if (ret != nSize)
+        {
+            closesocket(hSocket);
+            return error("Error sending to proxy\n");
+        }
+        char pchRet[8];
+        if (recv(hSocket, pchRet, 8, 0) != 8)
+        {
+            closesocket(hSocket);
+            return error("Error reading proxy response\n");
+        }
+        if (pchRet[1] != 0x5a)
+        {
+            closesocket(hSocket);
+            return error("Proxy returned error %d\n", pchRet[1]);
+        }
+        printf("Proxy connection established %s\n", addrConnect.ToString().c_str());
+    }
+
+    hSocketRet = hSocket;
+    return true;
+}
+
+
+
+bool GetMyExternalIP2(const CAddress& addrConnect, const char* pszGet, const char* pszKeyword, unsigned int& ipRet)
+{
+    SOCKET hSocket;
+    if (!ConnectSocket(addrConnect, hSocket))
+        return error("GetMyExternalIP() : connection to %s failed\n", addrConnect.ToString().c_str());
+
+    send(hSocket, pszGet, strlen(pszGet), 0);
+
+    string strLine;
+    while (RecvLine(hSocket, strLine))
+    {
+        if (strLine.empty())
+        {
+            loop
+            {
+                if (!RecvLine(hSocket, strLine))
+                {
+                    closesocket(hSocket);
+                    return false;
+                }
+                if (strLine.find(pszKeyword) != -1)
+                {
+                    strLine = strLine.substr(strLine.find(pszKeyword) + strlen(pszKeyword));
+                    break;
+                }
+            }
+            closesocket(hSocket);
+            if (strLine.find("<"))
+                strLine = strLine.substr(0, strLine.find("<"));
+            strLine = strLine.substr(strspn(strLine.c_str(), " \t\n\r"));
+            strLine = wxString(strLine).Trim();
+            CAddress addr(strLine.c_str());
+            printf("GetMyExternalIP() received [%s] %s\n", strLine.c_str(), addr.ToString().c_str());
+            if (addr.ip == 0 || !addr.IsRoutable())
+                return false;
+            ipRet = addr.ip;
+            return true;
+        }
+    }
+    closesocket(hSocket);
+    return error("GetMyExternalIP() : connection closed\n");
+}
+
+
+bool GetMyExternalIP(unsigned int& ipRet)
+{
+    CAddress addrConnect;
+    char* pszGet;
+    char* pszKeyword;
+
+    for (int nLookup = 0; nLookup <= 1; nLookup++)
+    for (int nHost = 1; nHost <= 2; nHost++)
+    {
+        if (nHost == 1)
+        {
+            addrConnect = CAddress("70.86.96.218:80"); // www.ipaddressworld.com
+
+            if (nLookup == 1)
+            {
+                struct hostent* phostent = gethostbyname("www.ipaddressworld.com");
+                if (phostent && phostent->h_addr_list && phostent->h_addr_list[0])
+                    addrConnect = CAddress(*(u_long*)phostent->h_addr_list[0], htons(80));
+            }
+
+            pszGet = "GET /ip.php HTTP/1.1\r\n"
+                     "Host: www.ipaddressworld.com\r\n"
+                     "User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)\r\n"
+                     "Connection: close\r\n"
+                     "\r\n";
+
+            pszKeyword = "IP:";
+        }
+        else if (nHost == 2)
+        {
+            addrConnect = CAddress("208.78.68.70:80"); // checkip.dyndns.org
+
+            if (nLookup == 1)
+            {
+                struct hostent* phostent = gethostbyname("checkip.dyndns.org");
+                if (phostent && phostent->h_addr_list && phostent->h_addr_list[0])
+                    addrConnect = CAddress(*(u_long*)phostent->h_addr_list[0], htons(80));
+            }
+
+            pszGet = "GET / HTTP/1.1\r\n"
+                     "Host: checkip.dyndns.org\r\n"
+                     "User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)\r\n"
+                     "Connection: close\r\n"
+                     "\r\n";
+
+            pszKeyword = "Address:";
+        }
+
+        if (GetMyExternalIP2(addrConnect, pszGet, pszKeyword, ipRet))
+            return true;
+    }
+
+    return false;
+}
+
+
+
+
+
+bool AddAddress(CAddrDB& addrdb, const CAddress& addr)
+{
+    if (!addr.IsRoutable())
+        return false;
+    if (addr.ip == addrLocalHost.ip)
+        return false;
+    CRITICAL_BLOCK(cs_mapAddresses)
+    {
+        map<vector<unsigned char>, CAddress>::iterator it = mapAddresses.find(addr.GetKey());
+        if (it == mapAddresses.end())
+        {
+            // New address
+            mapAddresses.insert(make_pair(addr.GetKey(), addr));
+            addrdb.WriteAddress(addr);
+            return true;
+        }
+        else
+        {
+            CAddress& addrFound = (*it).second;
+            if ((addrFound.nServices | addr.nServices) != addrFound.nServices)
+            {
+                // Services have been added
+                addrFound.nServices |= addr.nServices;
+                addrdb.WriteAddress(addrFound);
+                return true;
+            }
+        }
+    }
+    return false;
+}
+
+
+
+
+
+void AbandonRequests(void (*fn)(void*, CDataStream&), void* param1)
+{
+    // If the dialog might get closed before the reply comes back,
+    // call this in the destructor so it doesn't get called after it's deleted.
+    CRITICAL_BLOCK(cs_vNodes)
+    {
+        foreach(CNode* pnode, vNodes)
+        {
+            CRITICAL_BLOCK(pnode->cs_mapRequests)
+            {
+                for (map<uint256, CRequestTracker>::iterator mi = pnode->mapRequests.begin(); mi != pnode->mapRequests.end();)
+                {
+                    CRequestTracker& tracker = (*mi).second;
+                    if (tracker.fn == fn && tracker.param1 == param1)
+                        pnode->mapRequests.erase(mi++);
+                    else
+                        mi++;
+                }
+            }
+        }
+    }
+}
+
+
+
+
+
+
+
+//
+// Subscription methods for the broadcast and subscription system.
+// Channel numbers are message numbers, i.e. MSG_TABLE and MSG_PRODUCT.
+//
+// The subscription system uses a meet-in-the-middle strategy.
+// With 100,000 nodes, if senders broadcast to 1000 random nodes and receivers
+// subscribe to 1000 random nodes, 99.995% (1 - 0.99^1000) of messages will get through.
+//
+
+bool AnySubscribed(unsigned int nChannel)
+{
+    if (pnodeLocalHost->IsSubscribed(nChannel))
+        return true;
+    CRITICAL_BLOCK(cs_vNodes)
+        foreach(CNode* pnode, vNodes)
+            if (pnode->IsSubscribed(nChannel))
+                return true;
+    return false;
+}
+
+bool CNode::IsSubscribed(unsigned int nChannel)
+{
+    if (nChannel >= vfSubscribe.size())
+        return false;
+    return vfSubscribe[nChannel];
+}
+
+void CNode::Subscribe(unsigned int nChannel, unsigned int nHops)
+{
+    if (nChannel >= vfSubscribe.size())
+        return;
+
+    if (!AnySubscribed(nChannel))
+    {
+        // Relay subscribe
+        CRITICAL_BLOCK(cs_vNodes)
+            foreach(CNode* pnode, vNodes)
+                if (pnode != this)
+                    pnode->PushMessage("subscribe", nChannel, nHops);
+    }
+
+    vfSubscribe[nChannel] = true;
+}
+
+void CNode::CancelSubscribe(unsigned int nChannel)
+{
+    if (nChannel >= vfSubscribe.size())
+        return;
+
+    // Prevent from relaying cancel if wasn't subscribed
+    if (!vfSubscribe[nChannel])
+        return;
+    vfSubscribe[nChannel] = false;
+
+    if (!AnySubscribed(nChannel))
+    {
+        // Relay subscription cancel
+        CRITICAL_BLOCK(cs_vNodes)
+            foreach(CNode* pnode, vNodes)
+                if (pnode != this)
+                    pnode->PushMessage("sub-cancel", nChannel);
+
+        // Clear memory, no longer subscribed
+        if (nChannel == MSG_PRODUCT)
+            CRITICAL_BLOCK(cs_mapProducts)
+                mapProducts.clear();
+    }
+}
+
+
+
+
+
+
+
+
+
+CNode* FindNode(unsigned int ip)
+{
+    CRITICAL_BLOCK(cs_vNodes)
+    {
+        foreach(CNode* pnode, vNodes)
+            if (pnode->addr.ip == ip)
+                return (pnode);
+    }
+    return NULL;
+}
+
+CNode* FindNode(CAddress addr)
+{
+    CRITICAL_BLOCK(cs_vNodes)
+    {
+        foreach(CNode* pnode, vNodes)
+            if (pnode->addr == addr)
+                return (pnode);
+    }
+    return NULL;
+}
+
+CNode* ConnectNode(CAddress addrConnect, int64 nTimeout)
+{
+    if (addrConnect.ip == addrLocalHost.ip)
+        return NULL;
+
+    // Look for an existing connection
+    CNode* pnode = FindNode(addrConnect.ip);
+    if (pnode)
+    {
+        if (nTimeout != 0)
+            pnode->AddRef(nTimeout);
+        else
+            pnode->AddRef();
+        return pnode;
+    }
+
+    /// debug print
+    printf("trying %s\n", addrConnect.ToString().c_str());
+
+    // Connect
+    SOCKET hSocket;
+    if (ConnectSocket(addrConnect, hSocket))
+    {
+        /// debug print
+        printf("connected %s\n", addrConnect.ToString().c_str());
+
+        // Set to nonblocking
+        u_long nOne = 1;
+        if (ioctlsocket(hSocket, FIONBIO, &nOne) == SOCKET_ERROR)
+            printf("ConnectSocket() : ioctlsocket nonblocking setting failed, error %d\n", WSAGetLastError());
+
+        // Add node
+        CNode* pnode = new CNode(hSocket, addrConnect, false);
+        if (nTimeout != 0)
+            pnode->AddRef(nTimeout);
+        else
+            pnode->AddRef();
+        CRITICAL_BLOCK(cs_vNodes)
+            vNodes.push_back(pnode);
+
+        CRITICAL_BLOCK(cs_mapAddresses)
+            mapAddresses[addrConnect.GetKey()].nLastFailed = 0;
+        return pnode;
+    }
+    else
+    {
+        CRITICAL_BLOCK(cs_mapAddresses)
+            mapAddresses[addrConnect.GetKey()].nLastFailed = GetTime();
+        return NULL;
+    }
+}
+
+void CNode::Disconnect()
+{
+    printf("disconnecting node %s\n", addr.ToString().c_str());
+
+    closesocket(hSocket);
+
+    // If outbound and never got version message, mark address as failed
+    if (!fInbound && nVersion == 0)
+        CRITICAL_BLOCK(cs_mapAddresses)
+            mapAddresses[addr.GetKey()].nLastFailed = GetTime();
+
+    // All of a nodes broadcasts and subscriptions are automatically torn down
+    // when it goes down, so a node has to stay up to keep its broadcast going.
+
+    CRITICAL_BLOCK(cs_mapProducts)
+        for (map<uint256, CProduct>::iterator mi = mapProducts.begin(); mi != mapProducts.end();)
+            AdvertRemoveSource(this, MSG_PRODUCT, 0, (*(mi++)).second);
+
+    // Cancel subscriptions
+    for (unsigned int nChannel = 0; nChannel < vfSubscribe.size(); nChannel++)
+        if (vfSubscribe[nChannel])
+            CancelSubscribe(nChannel);
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+void ThreadSocketHandler(void* parg)
+{
+    IMPLEMENT_RANDOMIZE_STACK(ThreadSocketHandler(parg));
+
+    loop
+    {
+        vfThreadRunning[0] = true;
+        CheckForShutdown(0);
+        try
+        {
+            ThreadSocketHandler2(parg);
+        }
+        CATCH_PRINT_EXCEPTION("ThreadSocketHandler()")
+        vfThreadRunning[0] = false;
+        Sleep(5000);
+    }
+}
+
+void ThreadSocketHandler2(void* parg)
+{
+    printf("ThreadSocketHandler started\n");
+    SOCKET hListenSocket = *(SOCKET*)parg;
+    list<CNode*> vNodesDisconnected;
+    int nPrevNodeCount = 0;
+
+    loop
+    {
+        //
+        // Disconnect nodes
+        //
+        CRITICAL_BLOCK(cs_vNodes)
+        {
+            // Disconnect unused nodes
+            vector<CNode*> vNodesCopy = vNodes;
+            foreach(CNode* pnode, vNodesCopy)
+            {
+                if (pnode->ReadyToDisconnect() && pnode->vRecv.empty() && pnode->vSend.empty())
+                {
+                    // remove from vNodes
+                    vNodes.erase(remove(vNodes.begin(), vNodes.end(), pnode), vNodes.end());
+                    pnode->Disconnect();
+
+                    // hold in disconnected pool until all refs are released
+                    pnode->nReleaseTime = max(pnode->nReleaseTime, GetTime() + 5 * 60);
+                    if (pnode->fNetworkNode)
+                        pnode->Release();
+                    vNodesDisconnected.push_back(pnode);
+                }
+            }
+
+            // Delete disconnected nodes
+            list<CNode*> vNodesDisconnectedCopy = vNodesDisconnected;
+            foreach(CNode* pnode, vNodesDisconnectedCopy)
+            {
+                // wait until threads are done using it
+                if (pnode->GetRefCount() <= 0)
+                {
+                    bool fDelete = false;
+                    TRY_CRITICAL_BLOCK(pnode->cs_vSend)
+                     TRY_CRITICAL_BLOCK(pnode->cs_vRecv)
+                      TRY_CRITICAL_BLOCK(pnode->cs_mapRequests)
+                       TRY_CRITICAL_BLOCK(pnode->cs_inventory)
+                        fDelete = true;
+                    if (fDelete)
+                    {
+                        vNodesDisconnected.remove(pnode);
+                        delete pnode;
+                    }
+                }
+            }
+        }
+        if (vNodes.size() != nPrevNodeCount)
+        {
+            nPrevNodeCount = vNodes.size();
+            MainFrameRepaint();
+        }
+
+
+        //
+        // Find which sockets have data to receive
+        //
+        struct timeval timeout;
+        timeout.tv_sec  = 0;
+        timeout.tv_usec = 50000; // frequency to poll pnode->vSend
+
+        struct fd_set fdsetRecv;
+        struct fd_set fdsetSend;
+        FD_ZERO(&fdsetRecv);
+        FD_ZERO(&fdsetSend);
+        SOCKET hSocketMax = 0;
+        FD_SET(hListenSocket, &fdsetRecv);
+        hSocketMax = max(hSocketMax, hListenSocket);
+        CRITICAL_BLOCK(cs_vNodes)
+        {
+            foreach(CNode* pnode, vNodes)
+            {
+                FD_SET(pnode->hSocket, &fdsetRecv);
+                hSocketMax = max(hSocketMax, pnode->hSocket);
+                TRY_CRITICAL_BLOCK(pnode->cs_vSend)
+                    if (!pnode->vSend.empty())
+                        FD_SET(pnode->hSocket, &fdsetSend);
+            }
+        }
+
+        vfThreadRunning[0] = false;
+        int nSelect = select(hSocketMax + 1, &fdsetRecv, &fdsetSend, NULL, &timeout);
+        vfThreadRunning[0] = true;
+        CheckForShutdown(0);
+        if (nSelect == SOCKET_ERROR)
+        {
+            int nErr = WSAGetLastError();
+            printf("select failed: %d\n", nErr);
+            for (int i = 0; i <= hSocketMax; i++)
+            {
+                FD_SET(i, &fdsetRecv);
+                FD_SET(i, &fdsetSend);
+            }
+            Sleep(timeout.tv_usec/1000);
+        }
+        RandAddSeed();
+
+        //// debug print
+        //foreach(CNode* pnode, vNodes)
+        //{
+        //    printf("vRecv = %-5d ", pnode->vRecv.size());
+        //    printf("vSend = %-5d    ", pnode->vSend.size());
+        //}
+        //printf("\n");
+
+
+        //
+        // Accept new connections
+        //
+        if (FD_ISSET(hListenSocket, &fdsetRecv))
+        {
+            struct sockaddr_in sockaddr;
+            int len = sizeof(sockaddr);
+            SOCKET hSocket = accept(hListenSocket, (struct sockaddr*)&sockaddr, &len);
+            CAddress addr(sockaddr);
+            if (hSocket == INVALID_SOCKET)
+            {
+                if (WSAGetLastError() != WSAEWOULDBLOCK)
+                    printf("ERROR ThreadSocketHandler accept failed: %d\n", WSAGetLastError());
+            }
+            else
+            {
+                printf("accepted connection from %s\n", addr.ToString().c_str());
+                CNode* pnode = new CNode(hSocket, addr, true);
+                pnode->AddRef();
+                CRITICAL_BLOCK(cs_vNodes)
+                    vNodes.push_back(pnode);
+            }
+        }
+
+
+        //
+        // Service each socket
+        //
+        vector<CNode*> vNodesCopy;
+        CRITICAL_BLOCK(cs_vNodes)
+            vNodesCopy = vNodes;
+        foreach(CNode* pnode, vNodesCopy)
+        {
+            CheckForShutdown(0);
+            SOCKET hSocket = pnode->hSocket;
+
+            //
+            // Receive
+            //
+            if (FD_ISSET(hSocket, &fdsetRecv))
+            {
+                TRY_CRITICAL_BLOCK(pnode->cs_vRecv)
+                {
+                    CDataStream& vRecv = pnode->vRecv;
+                    unsigned int nPos = vRecv.size();
+
+                    // typical socket buffer is 8K-64K
+                    const unsigned int nBufSize = 0x10000;
+                    vRecv.resize(nPos + nBufSize);
+                    int nBytes = recv(hSocket, &vRecv[nPos], nBufSize, 0);
+                    vRecv.resize(nPos + max(nBytes, 0));
+                    if (nBytes == 0)
+                    {
+                        // socket closed gracefully
+                        if (!pnode->fDisconnect)
+                            printf("recv: socket closed\n");
+                        pnode->fDisconnect = true;
+                    }
+                    else if (nBytes < 0)
+                    {
+                        // socket error
+                        int nErr = WSAGetLastError();
+                        if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)
+                        {
+                            if (!pnode->fDisconnect)
+                                printf("recv failed: %d\n", nErr);
+                            pnode->fDisconnect = true;
+                        }
+                    }
+                }
+            }
+
+            //
+            // Send
+            //
+            if (FD_ISSET(hSocket, &fdsetSend))
+            {
+                TRY_CRITICAL_BLOCK(pnode->cs_vSend)
+                {
+                    CDataStream& vSend = pnode->vSend;
+                    if (!vSend.empty())
+                    {
+                        int nBytes = send(hSocket, &vSend[0], vSend.size(), 0);
+                        if (nBytes > 0)
+                        {
+                            vSend.erase(vSend.begin(), vSend.begin() + nBytes);
+                        }
+                        else if (nBytes == 0)
+                        {
+                            if (pnode->ReadyToDisconnect())
+                                pnode->vSend.clear();
+                        }
+                        else
+                        {
+                            printf("send error %d\n", nBytes);
+                            if (pnode->ReadyToDisconnect())
+                                pnode->vSend.clear();
+                        }
+                    }
+                }
+            }
+        }
+
+
+        Sleep(10);
+    }
+}
+
+
+
+
+
+
+
+
+
+
+void ThreadOpenConnections(void* parg)
+{
+    IMPLEMENT_RANDOMIZE_STACK(ThreadOpenConnections(parg));
+
+    loop
+    {
+        vfThreadRunning[1] = true;
+        CheckForShutdown(1);
+        try
+        {
+            ThreadOpenConnections2(parg);
+        }
+        CATCH_PRINT_EXCEPTION("ThreadOpenConnections()")
+        vfThreadRunning[1] = false;
+        Sleep(5000);
+    }
+}
+
+void ThreadOpenConnections2(void* parg)
+{
+    printf("ThreadOpenConnections started\n");
+
+    // Initiate network connections
+    int nTry = 0;
+    bool fIRCOnly = false;
+    const int nMaxConnections = 15;
+    loop
+    {
+        // Wait
+        vfThreadRunning[1] = false;
+        Sleep(500);
+        while (vNodes.size() >= nMaxConnections || vNodes.size() >= mapAddresses.size())
+        {
+            CheckForShutdown(1);
+            Sleep(2000);
+        }
+        vfThreadRunning[1] = true;
+        CheckForShutdown(1);
+
+
+        //
+        // The IP selection process is designed to limit vulnerability to address flooding.
+        // Any class C (a.b.c.?) has an equal chance of being chosen, then an IP is
+        // chosen within the class C.  An attacker may be able to allocate many IPs, but
+        // they would normally be concentrated in blocks of class C's.  They can hog the
+        // attention within their class C, but not the whole IP address space overall.
+        // A lone node in a class C will get as much attention as someone holding all 255
+        // IPs in another class C.
+        //
+
+        // Every other try is with IRC addresses only
+        fIRCOnly = !fIRCOnly;
+        if (mapIRCAddresses.empty())
+            fIRCOnly = false;
+        else if (nTry++ < 30 && vNodes.size() < nMaxConnections/2)
+            fIRCOnly = true;
+
+        // Make a list of unique class C's
+        unsigned char pchIPCMask[4] = { 0xff, 0xff, 0xff, 0x00 };
+        unsigned int nIPCMask = *(unsigned int*)pchIPCMask;
+        vector<unsigned int> vIPC;
+        CRITICAL_BLOCK(cs_mapIRCAddresses)
+        CRITICAL_BLOCK(cs_mapAddresses)
+        {
+            vIPC.reserve(mapAddresses.size());
+            unsigned int nPrev = 0;
+            foreach(const PAIRTYPE(vector<unsigned char>, CAddress)& item, mapAddresses)
+            {
+                const CAddress& addr = item.second;
+                if (!addr.IsIPv4())
+                    continue;
+                if (fIRCOnly && !mapIRCAddresses.count(item.first))
+                    continue;
+
+                // Taking advantage of mapAddresses being in sorted order,
+                // with IPs of the same class C grouped together.
+                unsigned int ipC = addr.ip & nIPCMask;
+                if (ipC != nPrev)
+                    vIPC.push_back(nPrev = ipC);
+            }
+        }
+        if (vIPC.empty())
+            continue;
+
+        // Choose a random class C
+        unsigned int ipC = vIPC[GetRand(vIPC.size())];
+
+        // Organize all addresses in the class C by IP
+        map<unsigned int, vector<CAddress> > mapIP;
+        CRITICAL_BLOCK(cs_mapIRCAddresses)
+        CRITICAL_BLOCK(cs_mapAddresses)
+        {
+            int64 nDelay = ((30 * 60) << vNodes.size());
+            if (!fIRCOnly)
+            {
+                nDelay *= 2;
+                if (vNodes.size() >= 3)
+                    nDelay *= 4;
+                if (!mapIRCAddresses.empty())
+                    nDelay *= 100;
+            }
+
+            for (map<vector<unsigned char>, CAddress>::iterator mi = mapAddresses.lower_bound(CAddress(ipC, 0).GetKey());
+                 mi != mapAddresses.upper_bound(CAddress(ipC | ~nIPCMask, 0xffff).GetKey());
+                 ++mi)
+            {
+                const CAddress& addr = (*mi).second;
+                if (fIRCOnly && !mapIRCAddresses.count((*mi).first))
+                    continue;
+
+                int64 nRandomizer = (addr.nLastFailed * addr.ip * 7777U) % 20000;
+                if (GetTime() - addr.nLastFailed > nDelay * nRandomizer / 10000)
+                    mapIP[addr.ip].push_back(addr);
+            }
+        }
+        if (mapIP.empty())
+            continue;
+
+        // Choose a random IP in the class C
+        map<unsigned int, vector<CAddress> >::iterator mi = mapIP.begin();
+        advance(mi, GetRand(mapIP.size()));
+
+        // Once we've chosen an IP, we'll try every given port before moving on
+        foreach(const CAddress& addrConnect, (*mi).second)
+        {
+            //
+            // Initiate outbound network connection
+            //
+            CheckForShutdown(1);
+            if (addrConnect.ip == addrLocalHost.ip || !addrConnect.IsIPv4() || FindNode(addrConnect.ip))
+                continue;
+
+            vfThreadRunning[1] = false;
+            CNode* pnode = ConnectNode(addrConnect);
+            vfThreadRunning[1] = true;
+            CheckForShutdown(1);
+            if (!pnode)
+                continue;
+            pnode->fNetworkNode = true;
+
+            if (addrLocalHost.IsRoutable())
+            {
+                // Advertise our address
+                vector<CAddress> vAddrToSend;
+                vAddrToSend.push_back(addrLocalHost);
+                pnode->PushMessage("addr", vAddrToSend);
+            }
+
+            // Get as many addresses as we can
+            pnode->PushMessage("getaddr");
+
+            ////// should the one on the receiving end do this too?
+            // Subscribe our local subscription list
+            const unsigned int nHops = 0;
+            for (unsigned int nChannel = 0; nChannel < pnodeLocalHost->vfSubscribe.size(); nChannel++)
+                if (pnodeLocalHost->vfSubscribe[nChannel])
+                    pnode->PushMessage("subscribe", nChannel, nHops);
+
+            break;
+        }
+    }
+}
+
+
+
+
+
+
+
+
+void ThreadMessageHandler(void* parg)
+{
+    IMPLEMENT_RANDOMIZE_STACK(ThreadMessageHandler(parg));
+
+    loop
+    {
+        vfThreadRunning[2] = true;
+        CheckForShutdown(2);
+        try
+        {
+            ThreadMessageHandler2(parg);
+        }
+        CATCH_PRINT_EXCEPTION("ThreadMessageHandler()")
+        vfThreadRunning[2] = false;
+        Sleep(5000);
+    }
+}
+
+void ThreadMessageHandler2(void* parg)
+{
+    printf("ThreadMessageHandler started\n");
+    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_BELOW_NORMAL);
+    loop
+    {
+        // Poll the connected nodes for messages
+        vector<CNode*> vNodesCopy;
+        CRITICAL_BLOCK(cs_vNodes)
+            vNodesCopy = vNodes;
+        foreach(CNode* pnode, vNodesCopy)
+        {
+            pnode->AddRef();
+
+            // Receive messages
+            TRY_CRITICAL_BLOCK(pnode->cs_vRecv)
+                ProcessMessages(pnode);
+
+            // Send messages
+            TRY_CRITICAL_BLOCK(pnode->cs_vSend)
+                SendMessages(pnode);
+
+            pnode->Release();
+        }
+
+        // Wait and allow messages to bunch up
+        vfThreadRunning[2] = false;
+        Sleep(100);
+        vfThreadRunning[2] = true;
+        CheckForShutdown(2);
+    }
+}
+
+
+
+
+
+
+
+
+
+//// todo: start one thread per processor, use getenv("NUMBER_OF_PROCESSORS")
+void ThreadBitcoinMiner(void* parg)
+{
+    vfThreadRunning[3] = true;
+    CheckForShutdown(3);
+    try
+    {
+        bool fRet = BitcoinMiner();
+        printf("BitcoinMiner returned %s\n\n\n", fRet ? "true" : "false");
+    }
+    CATCH_PRINT_EXCEPTION("BitcoinMiner()")
+    vfThreadRunning[3] = false;
+}
+
+
+
+
+
+
+
+
+
+
+
+bool StartNode(string& strError)
+{
+    strError = "";
+
+    // Sockets startup
+    WSADATA wsadata;
+    int ret = WSAStartup(MAKEWORD(2,2), &wsadata);
+    if (ret != NO_ERROR)
+    {
+        strError = strprintf("Error: TCP/IP socket library failed to start (WSAStartup returned error %d)", ret);
+        printf("%s\n", strError.c_str());
+        return false;
+    }
+
+    // Get local host ip
+    char pszHostName[255];
+    if (gethostname(pszHostName, 255) == SOCKET_ERROR)
+    {
+        strError = strprintf("Error: Unable to get IP address of this computer (gethostname returned error %d)", WSAGetLastError());
+        printf("%s\n", strError.c_str());
+        return false;
+    }
+    struct hostent* phostent = gethostbyname(pszHostName);
+    if (!phostent)
+    {
+        strError = strprintf("Error: Unable to get IP address of this computer (gethostbyname returned error %d)", WSAGetLastError());
+        printf("%s\n", strError.c_str());
+        return false;
+    }
+    addrLocalHost = CAddress(*(long*)(phostent->h_addr_list[0]),
+                             DEFAULT_PORT,
+                             nLocalServices);
+    printf("addrLocalHost = %s\n", addrLocalHost.ToString().c_str());
+
+    // Create socket for listening for incoming connections
+    SOCKET hListenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
+    if (hListenSocket == INVALID_SOCKET)
+    {
+        strError = strprintf("Error: Couldn't open socket for incoming connections (socket returned error %d)", WSAGetLastError());
+        printf("%s\n", strError.c_str());
+        return false;
+    }
+
+    // Set to nonblocking, incoming connections will also inherit this
+    u_long nOne = 1;
+    if (ioctlsocket(hListenSocket, FIONBIO, &nOne) == SOCKET_ERROR)
+    {
+        strError = strprintf("Error: Couldn't set properties on socket for incoming connections (ioctlsocket returned error %d)", WSAGetLastError());
+        printf("%s\n", strError.c_str());
+        return false;
+    }
+
+    // The sockaddr_in structure specifies the address family,
+    // IP address, and port for the socket that is being bound
+    int nRetryLimit = 15;
+    struct sockaddr_in sockaddr = addrLocalHost.GetSockAddr();
+    if (bind(hListenSocket, (struct sockaddr*)&sockaddr, sizeof(sockaddr)) == SOCKET_ERROR)
+    {
+        int nErr = WSAGetLastError();
+        if (nErr == WSAEADDRINUSE)
+            strError = strprintf("Error: Unable to bind to port %s on this computer. The program is probably already running.", addrLocalHost.ToString().c_str());
+        else
+            strError = strprintf("Error: Unable to bind to port %s on this computer (bind returned error %d)", addrLocalHost.ToString().c_str(), nErr);
+        printf("%s\n", strError.c_str());
+        return false;
+    }
+    printf("bound to addrLocalHost = %s\n\n", addrLocalHost.ToString().c_str());
+
+    // Listen for incoming connections
+    if (listen(hListenSocket, SOMAXCONN) == SOCKET_ERROR)
+    {
+        strError = strprintf("Error: Listening for incoming connections failed (listen returned error %d)", WSAGetLastError());
+        printf("%s\n", strError.c_str());
+        return false;
+    }
+
+    // Get our external IP address for incoming connections
+    if (addrIncoming.ip)
+        addrLocalHost.ip = addrIncoming.ip;
+
+    if (GetMyExternalIP(addrLocalHost.ip))
+    {
+        addrIncoming = addrLocalHost;
+        CWalletDB().WriteSetting("addrIncoming", addrIncoming);
+    }
+
+    // Get addresses from IRC and advertise ours
+    if (_beginthread(ThreadIRCSeed, 0, NULL) == -1)
+        printf("Error: _beginthread(ThreadIRCSeed) failed\n");
+
+    //
+    // Start threads
+    //
+    if (_beginthread(ThreadSocketHandler, 0, new SOCKET(hListenSocket)) == -1)
+    {
+        strError = "Error: _beginthread(ThreadSocketHandler) failed";
+        printf("%s\n", strError.c_str());
+        return false;
+    }
+
+    if (_beginthread(ThreadOpenConnections, 0, NULL) == -1)
+    {
+        strError = "Error: _beginthread(ThreadOpenConnections) failed";
+        printf("%s\n", strError.c_str());
+        return false;
+    }
+
+    if (_beginthread(ThreadMessageHandler, 0, NULL) == -1)
+    {
+        strError = "Error: _beginthread(ThreadMessageHandler) failed";
+        printf("%s\n", strError.c_str());
+        return false;
+    }
+
+    return true;
+}
+
+bool StopNode()
+{
+    printf("StopNode()\n");
+    fShutdown = true;
+    nTransactionsUpdated++;
+    int64 nStart = GetTime();
+    while (vfThreadRunning[0] || vfThreadRunning[2] || vfThreadRunning[3])
+    {
+        if (GetTime() - nStart > 15)
+            break;
+        Sleep(20);
+    }
+    if (vfThreadRunning[0]) printf("ThreadSocketHandler still running\n");
+    if (vfThreadRunning[1]) printf("ThreadOpenConnections still running\n");
+    if (vfThreadRunning[2]) printf("ThreadMessageHandler still running\n");
+    if (vfThreadRunning[3]) printf("ThreadBitcoinMiner still running\n");
+    while (vfThreadRunning[2])
+        Sleep(20);
+    Sleep(50);
+
+    // Sockets shutdown
+    WSACleanup();
+    return true;
+}
+
+void CheckForShutdown(int n)
+{
+    if (fShutdown)
+    {
+        if (n != -1)
+            vfThreadRunning[n] = false;
+        if (n == 0)
+            foreach(CNode* pnode, vNodes)
+                closesocket(pnode->hSocket);
+        _endthread();
+    }
+}
/trunk/net.h Diff Switch to side-by-side view
--- a
+++ b/trunk/net.h
@@ -0,0 +1,856 @@
+// Copyright (c) 2009 Satoshi Nakamoto
+// Distributed under the MIT/X11 software license, see the accompanying
+// file license.txt or http://www.opensource.org/licenses/mit-license.php.
+
+class CMessageHeader;
+class CAddress;
+class CInv;
+class CRequestTracker;
+class CNode;
+
+
+
+static const unsigned short DEFAULT_PORT = htons(8333);
+static const unsigned int PUBLISH_HOPS = 5;
+enum
+{
+    NODE_NETWORK = (1 << 0),
+};
+
+
+
+
+
+
+bool ConnectSocket(const CAddress& addrConnect, SOCKET& hSocketRet);
+bool GetMyExternalIP(unsigned int& ipRet);
+bool AddAddress(CAddrDB& addrdb, const CAddress& addr);
+CNode* FindNode(unsigned int ip);
+CNode* ConnectNode(CAddress addrConnect, int64 nTimeout=0);
+void AbandonRequests(void (*fn)(void*, CDataStream&), void* param1);
+bool AnySubscribed(unsigned int nChannel);
+void ThreadBitcoinMiner(void* parg);
+bool StartNode(string& strError=REF(string()));
+bool StopNode();
+void CheckForShutdown(int n);
+
+
+
+
+
+
+
+
+
+//
+// Message header
+//  (4) message start
+//  (12) command
+//  (4) size
+
+// The message start string is designed to be unlikely to occur in normal data.
+// The characters are rarely used upper ascii, not valid as UTF-8, and produce
+// a large 4-byte int at any alignment.
+static const char pchMessageStart[4] = { 0xf9, 0xbe, 0xb4, 0xd9 };
+
+class CMessageHeader
+{
+public:
+    enum { COMMAND_SIZE=12 };
+    char pchMessageStart[sizeof(::pchMessageStart)];
+    char pchCommand[COMMAND_SIZE];
+    unsigned int nMessageSize;
+
+    CMessageHeader()
+    {
+        memcpy(pchMessageStart, ::pchMessageStart, sizeof(pchMessageStart));
+        memset(pchCommand, 0, sizeof(pchCommand));
+        pchCommand[1] = 1;
+        nMessageSize = -1;
+    }
+
+    CMessageHeader(const char* pszCommand, unsigned int nMessageSizeIn)
+    {
+        memcpy(pchMessageStart, ::pchMessageStart, sizeof(pchMessageStart));
+        strncpy(pchCommand, pszCommand, COMMAND_SIZE);
+        nMessageSize = nMessageSizeIn;
+    }
+
+    IMPLEMENT_SERIALIZE
+    (
+        READWRITE(FLATDATA(pchMessageStart));
+        READWRITE(FLATDATA(pchCommand));
+        READWRITE(nMessageSize);
+    )
+
+    string GetCommand()
+    {
+        if (pchCommand[COMMAND_SIZE-1] == 0)
+            return string(pchCommand, pchCommand + strlen(pchCommand));
+        else
+            return string(pchCommand, pchCommand + COMMAND_SIZE);
+    }
+
+    bool IsValid()
+    {
+        // Check start string
+        if (memcmp(pchMessageStart, ::pchMessageStart, sizeof(pchMessageStart)) != 0)
+            return false;
+
+        // Check the command string for errors
+        for (char* p1 = pchCommand; p1 < pchCommand + COMMAND_SIZE; p1++)
+        {
+            if (*p1 == 0)
+            {
+                // Must be all zeros after the first zero
+                for (; p1 < pchCommand + COMMAND_SIZE; p1++)
+                    if (*p1 != 0)
+                        return false;
+            }
+            else if (*p1 < ' ' || *p1 > 0x7E)
+                return false;
+        }
+
+        // Message size
+        if (nMessageSize > 0x10000000)
+        {
+            printf("CMessageHeader::IsValid() : nMessageSize too large %u\n", nMessageSize);
+            return false;
+        }
+
+        return true;
+    }
+};
+
+
+
+
+
+
+static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };
+
+class CAddress
+{
+public:
+    uint64 nServices;
+    unsigned char pchReserved[12];
+    unsigned int ip;
+    unsigned short port;
+
+    // disk only
+    unsigned int nTime;
+
+    // memory only
+    unsigned int nLastFailed;
+
+    CAddress()
+    {
+        nServices = 0;
+        memcpy(pchReserved, pchIPv4, sizeof(pchReserved));
+        ip = 0;
+        port = DEFAULT_PORT;
+        nTime = GetAdjustedTime();
+        nLastFailed = 0;
+    }
+
+    CAddress(unsigned int ipIn, unsigned short portIn=DEFAULT_PORT, uint64 nServicesIn=0)
+    {
+        nServices = nServicesIn;
+        memcpy(pchReserved, pchIPv4, sizeof(pchReserved));
+        ip = ipIn;
+        port = portIn;
+        nTime = GetAdjustedTime();
+        nLastFailed = 0;
+    }
+
+    explicit CAddress(const struct sockaddr_in& sockaddr, uint64 nServicesIn=0)
+    {
+        nServices = nServicesIn;
+        memcpy(pchReserved, pchIPv4, sizeof(pchReserved));
+        ip = sockaddr.sin_addr.s_addr;
+        port = sockaddr.sin_port;
+        nTime = GetAdjustedTime();
+        nLastFailed = 0;
+    }
+
+    explicit CAddress(const char* pszIn, uint64 nServicesIn=0)
+    {
+        nServices = nServicesIn;
+        memcpy(pchReserved, pchIPv4, sizeof(pchReserved));
+        ip = 0;
+        port = DEFAULT_PORT;
+        nTime = GetAdjustedTime();
+        nLastFailed = 0;
+
+        char psz[100];
+        if (strlen(pszIn) > ARRAYLEN(psz)-1)
+            return;
+        strcpy(psz, pszIn);
+        unsigned int a, b, c, d, e;
+        if (sscanf(psz, "%u.%u.%u.%u:%u", &a, &b, &c, &d, &e) < 4)
+            return;
+        char* pszPort = strchr(psz, ':');
+        if (pszPort)
+        {
+            *pszPort++ = '\0';
+            port = htons(atoi(pszPort));
+        }
+        ip = inet_addr(psz);
+    }
+
+    IMPLEMENT_SERIALIZE
+    (
+        if (nType & SER_DISK)
+        {
+            READWRITE(nVersion);
+            READWRITE(nTime);
+        }
+        READWRITE(nServices);
+        READWRITE(FLATDATA(pchReserved));
+        READWRITE(ip);
+        READWRITE(port);
+    )
+
+    friend inline bool operator==(const CAddress& a, const CAddress& b)
+    {
+        return (memcmp(a.pchReserved, b.pchReserved, sizeof(a.pchReserved)) == 0 &&
+                a.ip   == b.ip &&
+                a.port == b.port);
+    }
+
+    friend inline bool operator<(const CAddress& a, const CAddress& b)
+    {
+        int ret = memcmp(a.pchReserved, b.pchReserved, sizeof(a.pchReserved));
+        if (ret < 0)
+            return true;
+        else if (ret == 0)
+        {
+            if (ntohl(a.ip) < ntohl(b.ip))
+                return true;
+            else if (a.ip == b.ip)
+                return ntohs(a.port) < ntohs(b.port);
+        }
+        return false;
+    }
+
+    vector<unsigned char> GetKey() const
+    {
+        CDataStream ss;
+        ss.reserve(18);
+        ss << FLATDATA(pchReserved) << ip << port;
+
+        #if defined(_MSC_VER) && _MSC_VER < 1300
+        return vector<unsigned char>((unsigned char*)&ss.begin()[0], (unsigned char*)&ss.end()[0]);
+        #else
+        return vector<unsigned char>(ss.begin(), ss.end());
+        #endif
+    }
+
+    struct sockaddr_in GetSockAddr() const
+    {
+        struct sockaddr_in sockaddr;
+        sockaddr.sin_family = AF_INET;
+        sockaddr.sin_addr.s_addr = ip;
+        sockaddr.sin_port = port;
+        return sockaddr;
+    }
+
+    bool IsIPv4() const
+    {
+        return (memcmp(pchReserved, pchIPv4, sizeof(pchIPv4)) == 0);
+    }
+
+    bool IsRoutable() const
+    {
+        return !(GetByte(3) == 10 || (GetByte(3) == 192 && GetByte(2) == 168) || GetByte(3) == 127 || GetByte(3) == 0);
+    }
+
+    unsigned char GetByte(int n) const
+    {
+        return ((unsigned char*)&ip)[3-n];
+    }
+
+    string ToStringIPPort() const
+    {
+        return strprintf("%u.%u.%u.%u:%u", GetByte(3), GetByte(2), GetByte(1), GetByte(0), ntohs(port));
+    }
+
+    string ToStringIP() const
+    {
+        return strprintf("%u.%u.%u.%u", GetByte(3), GetByte(2), GetByte(1), GetByte(0));
+    }
+
+    string ToString() const
+    {
+        return strprintf("%u.%u.%u.%u:%u", GetByte(3), GetByte(2), GetByte(1), GetByte(0), ntohs(port));
+        //return strprintf("%u.%u.%u.%u", GetByte(3), GetByte(2), GetByte(1), GetByte(0));
+    }
+
+    void print() const
+    {
+        printf("CAddress(%s)\n", ToString().c_str());
+    }
+};
+
+
+
+
+
+
+
+enum
+{
+    MSG_TX = 1,
+    MSG_BLOCK,
+    MSG_REVIEW,
+    MSG_PRODUCT,
+    MSG_TABLE,
+};
+
+static const char* ppszTypeName[] =
+{
+    "ERROR",
+    "tx",
+    "block",
+    "review",
+    "product",
+    "table",
+};
+
+class CInv
+{
+public:
+    int type;
+    uint256 hash;
+
+    CInv()
+    {
+        type = 0;
+        hash = 0;
+    }
+
+    CInv(int typeIn, const uint256& hashIn)
+    {
+        type = typeIn;
+        hash = hashIn;
+    }
+
+    CInv(const string& strType, const uint256& hashIn)
+    {
+        int i;
+        for (i = 1; i < ARRAYLEN(ppszTypeName); i++)
+        {
+            if (strType == ppszTypeName[i])
+            {
+                type = i;
+                break;
+            }
+        }
+        if (i == ARRAYLEN(ppszTypeName))
+            throw std::out_of_range(strprintf("CInv::CInv(string, uint256) : unknown type '%s'", strType.c_str()));
+        hash = hashIn;
+    }
+
+    IMPLEMENT_SERIALIZE
+    (
+        READWRITE(type);
+        READWRITE(hash);
+    )
+
+    friend inline bool operator<(const CInv& a, const CInv& b)
+    {
+        return (a.type < b.type || (a.type == b.type && a.hash < b.hash));
+    }
+
+    bool IsKnownType() const
+    {
+        return (type >= 1 && type < ARRAYLEN(ppszTypeName));
+    }
+
+    const char* GetCommand() const
+    {
+        if (!IsKnownType())
+            throw std::out_of_range(strprintf("CInv::GetCommand() : type=% unknown type", type));
+        return ppszTypeName[type];
+    }
+
+    string ToString() const
+    {
+        return strprintf("%s %s", GetCommand(), hash.ToString().substr(0,14).c_str());
+    }
+
+    void print() const
+    {
+        printf("CInv(%s)\n", ToString().c_str());
+    }
+};
+
+
+
+
+
+class CRequestTracker
+{
+public:
+    void (*fn)(void*, CDataStream&);
+    void* param1;
+
+    explicit CRequestTracker(void (*fnIn)(void*, CDataStream&)=NULL, void* param1In=NULL)
+    {
+        fn = fnIn;
+        param1 = param1In;
+    }
+
+    bool IsNull()
+    {
+        return fn == NULL;
+    }
+};
+
+
+
+
+
+extern bool fClient;
+extern uint64 nLocalServices;
+extern CAddress addrLocalHost;
+extern CNode* pnodeLocalHost;
+extern bool fShutdown;
+extern array<bool, 10> vfThreadRunning;
+extern vector<CNode*> vNodes;
+extern CCriticalSection cs_vNodes;
+extern map<vector<unsigned char>, CAddress> mapAddresses;
+extern CCriticalSection cs_mapAddresses;
+extern map<CInv, CDataStream> mapRelay;
+extern deque<pair<int64, CInv> > vRelayExpiration;
+extern CCriticalSection cs_mapRelay;
+extern map<CInv, int64> mapAlreadyAskedFor;
+extern CAddress addrProxy;
+
+
+
+
+
+class CNode
+{
+public:
+    // socket
+    uint64 nServices;
+    SOCKET hSocket;
+    CDataStream vSend;
+    CDataStream vRecv;
+    CCriticalSection cs_vSend;
+    CCriticalSection cs_vRecv;
+    unsigned int nPushPos;
+    CAddress addr;
+    int nVersion;
+    bool fClient;
+    bool fInbound;
+    bool fNetworkNode;
+    bool fDisconnect;
+protected:
+    int nRefCount;
+public:
+    int64 nReleaseTime;
+    map<uint256, CRequestTracker> mapRequests;
+    CCriticalSection cs_mapRequests;
+
+    // flood
+    vector<CAddress> vAddrToSend;
+    set<CAddress> setAddrKnown;
+
+    // inventory based relay
+    set<CInv> setInventoryKnown;
+    set<CInv> setInventoryKnown2;
+    vector<CInv> vInventoryToSend;
+    CCriticalSection cs_inventory;
+    multimap<int64, CInv> mapAskFor;
+
+    // publish and subscription
+    vector<char> vfSubscribe;
+
+
+    CNode(SOCKET hSocketIn, CAddress addrIn, bool fInboundIn=false)
+    {
+        nServices = 0;
+        hSocket = hSocketIn;
+        vSend.SetType(SER_NETWORK);
+        vRecv.SetType(SER_NETWORK);
+        nPushPos = -1;
+        addr = addrIn;
+        nVersion = 0;
+        fClient = false; // set by version message
+        fInbound = fInboundIn;
+        fNetworkNode = false;
+        fDisconnect = false;
+        nRefCount = 0;
+        nReleaseTime = 0;
+        vfSubscribe.assign(256, false);
+
+        // Push a version message
+        /// when NTP implemented, change to just nTime = GetAdjustedTime()
+        int64 nTime = (fInbound ? GetAdjustedTime() : GetTime());
+        PushMessage("version", VERSION, nLocalServices, nTime, addr);
+    }
+
+    ~CNode()
+    {
+        if (hSocket != INVALID_SOCKET)
+            closesocket(hSocket);
+    }
+
+private:
+    CNode(const CNode&);
+    void operator=(const CNode&);
+public:
+
+
+    bool ReadyToDisconnect()
+    {
+        return fDisconnect || GetRefCount() <= 0;
+    }
+
+    int GetRefCount()
+    {
+        return max(nRefCount, 0) + (GetTime() < nReleaseTime ? 1 : 0);
+    }
+
+    void AddRef(int64 nTimeout=0)
+    {
+        if (nTimeout != 0)
+            nReleaseTime = max(nReleaseTime, GetTime() + nTimeout);
+        else
+            nRefCount++;
+    }
+
+    void Release()
+    {
+        nRefCount--;
+    }
+
+
+
+    void AddInventoryKnown(const CInv& inv)
+    {
+        CRITICAL_BLOCK(cs_inventory)
+            setInventoryKnown.insert(inv);
+    }
+
+    void PushInventory(const CInv& inv)
+    {
+        CRITICAL_BLOCK(cs_inventory)
+            if (!setInventoryKnown.count(inv))
+                vInventoryToSend.push_back(inv);
+    }
+
+    void AskFor(const CInv& inv)
+    {
+        // We're using mapAskFor as a priority queue,
+        // the key is the earliest time the request can be sent
+        int64& nRequestTime = mapAlreadyAskedFor[inv];
+        printf("askfor %s  %I64d\n", inv.ToString().c_str(), nRequestTime);
+
+        // Make sure not to reuse time indexes to keep things in the same order
+        int64 nNow = (GetTime() - 1) * 1000000;
+        static int64 nLastTime;
+        nLastTime = nNow = max(nNow, ++nLastTime);
+
+        // Each retry is 2 minutes after the last
+        nRequestTime = max(nRequestTime + 2 * 60 * 1000000, nNow);
+        mapAskFor.insert(make_pair(nRequestTime, inv));
+    }
+
+
+
+    void BeginMessage(const char* pszCommand)
+    {
+        EnterCriticalSection(&cs_vSend);
+        if (nPushPos != -1)
+            AbortMessage();
+        nPushPos = vSend.size();
+        vSend << CMessageHeader(pszCommand, 0);
+        printf("sending: %-12s ", pszCommand);
+    }
+
+    void AbortMessage()
+    {
+        if (nPushPos == -1)
+            return;
+        vSend.resize(nPushPos);
+        nPushPos = -1;
+        LeaveCriticalSection(&cs_vSend);
+        printf("(aborted)\n");
+    }
+
+    void EndMessage()
+    {
+        extern int nDropMessagesTest;
+        if (nDropMessagesTest > 0 && GetRand(nDropMessagesTest) == 0)
+        {
+            printf("dropmessages DROPPING SEND MESSAGE\n");
+            AbortMessage();
+            return;
+        }
+
+        if (nPushPos == -1)
+            return;
+
+        // Patch in the size
+        unsigned int nSize = vSend.size() - nPushPos - sizeof(CMessageHeader);
+        memcpy((char*)&vSend[nPushPos] + offsetof(CMessageHeader, nMessageSize), &nSize, sizeof(nSize));
+
+        printf("(%d bytes)  ", nSize);
+        //for (int i = nPushPos+sizeof(CMessageHeader); i < min(vSend.size(), nPushPos+sizeof(CMessageHeader)+20U); i++)
+        //    printf("%02x ", vSend[i] & 0xff);
+        printf("\n");
+
+        nPushPos = -1;
+        LeaveCriticalSection(&cs_vSend);
+    }
+
+    void EndMessageAbortIfEmpty()
+    {
+        if (nPushPos == -1)
+            return;
+        int nSize = vSend.size() - nPushPos - sizeof(CMessageHeader);
+        if (nSize > 0)
+            EndMessage();
+        else
+            AbortMessage();
+    }
+
+    const char* GetMessageCommand() const
+    {
+        if (nPushPos == -1)
+            return "";
+        return &vSend[nPushPos] + offsetof(CMessageHeader, pchCommand);
+    }
+
+
+
+
+    void PushMessage(const char* pszCommand)
+    {
+        try
+        {
+            BeginMessage(pszCommand);
+            EndMessage();
+        }
+        catch (...)
+        {
+            AbortMessage();
+            throw;
+        }
+    }
+
+    template<typename T1>
+    void PushMessage(const char* pszCommand, const T1& a1)
+    {
+        try
+        {
+            BeginMessage(pszCommand);
+            vSend << a1;
+            EndMessage();
+        }
+        catch (...)
+        {
+            AbortMessage();
+            throw;
+        }
+    }
+
+    template<typename T1, typename T2>
+    void PushMessage(const char* pszCommand, const T1& a1, const T2& a2)
+    {
+        try
+        {
+            BeginMessage(pszCommand);
+            vSend << a1 << a2;
+            EndMessage();
+        }
+        catch (...)
+        {
+            AbortMessage();
+            throw;
+        }
+    }
+
+    template<typename T1, typename T2, typename T3>
+    void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3)
+    {
+        try
+        {
+            BeginMessage(pszCommand);
+            vSend << a1 << a2 << a3;
+            EndMessage();
+        }
+        catch (...)
+        {
+            AbortMessage();
+            throw;
+        }
+    }
+
+    template<typename T1, typename T2, typename T3, typename T4>
+    void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4)
+    {
+        try
+        {
+            BeginMessage(pszCommand);
+            vSend << a1 << a2 << a3 << a4;
+            EndMessage();
+        }
+        catch (...)
+        {
+            AbortMessage();
+            throw;
+        }
+    }
+
+
+    void PushRequest(const char* pszCommand,
+                     void (*fn)(void*, CDataStream&), void* param1)
+    {
+        uint256 hashReply;
+        RAND_bytes((unsigned char*)&hashReply, sizeof(hashReply));
+
+        CRITICAL_BLOCK(cs_mapRequests)
+            mapRequests[hashReply] = CRequestTracker(fn, param1);
+
+        PushMessage(pszCommand, hashReply);
+    }
+
+    template<typename T1>
+    void PushRequest(const char* pszCommand, const T1& a1,
+                     void (*fn)(void*, CDataStream&), void* param1)
+    {
+        uint256 hashReply;
+        RAND_bytes((unsigned char*)&hashReply, sizeof(hashReply));
+
+        CRITICAL_BLOCK(cs_mapRequests)
+            mapRequests[hashReply] = CRequestTracker(fn, param1);
+
+        PushMessage(pszCommand, hashReply, a1);
+    }
+
+    template<typename T1, typename T2>
+    void PushRequest(const char* pszCommand, const T1& a1, const T2& a2,
+                     void (*fn)(void*, CDataStream&), void* param1)
+    {
+        uint256 hashReply;
+        RAND_bytes((unsigned char*)&hashReply, sizeof(hashReply));
+
+        CRITICAL_BLOCK(cs_mapRequests)
+            mapRequests[hashReply] = CRequestTracker(fn, param1);
+
+        PushMessage(pszCommand, hashReply, a1, a2);
+    }
+
+
+
+    bool IsSubscribed(unsigned int nChannel);
+    void Subscribe(unsigned int nChannel, unsigned int nHops=0);
+    void CancelSubscribe(unsigned int nChannel);
+    void Disconnect();
+};
+
+
+
+
+
+
+
+
+
+
+inline void RelayInventory(const CInv& inv)
+{
+    // Put on lists to offer to the other nodes
+    CRITICAL_BLOCK(cs_vNodes)
+        foreach(CNode* pnode, vNodes)
+            pnode->PushInventory(inv);
+}
+
+template<typename T>
+void RelayMessage(const CInv& inv, const T& a)
+{
+    CDataStream ss(SER_NETWORK);
+    ss.reserve(10000);
+    ss << a;
+    RelayMessage(inv, ss);
+}
+
+template<>
+inline void RelayMessage<>(const CInv& inv, const CDataStream& ss)
+{
+    CRITICAL_BLOCK(cs_mapRelay)
+    {
+        // Expire old relay messages
+        while (!vRelayExpiration.empty() && vRelayExpiration.front().first < GetTime())
+        {
+            mapRelay.erase(vRelayExpiration.front().second);
+            vRelayExpiration.pop_front();
+        }
+
+        // Save original serialized message so newer versions are preserved
+        mapRelay[inv] = ss;
+        vRelayExpiration.push_back(make_pair(GetTime() + 15 * 60, inv));
+    }
+
+    RelayInventory(inv);
+}
+
+
+
+
+
+
+
+
+//
+// Templates for the publish and subscription system.
+// The object being published as T& obj needs to have:
+//   a set<unsigned int> setSources member
+//   specializations of AdvertInsert and AdvertErase
+// Currently implemented for CTable and CProduct.
+//
+
+template<typename T>
+void AdvertStartPublish(CNode* pfrom, unsigned int nChannel, unsigned int nHops, T& obj)
+{
+    // Add to sources
+    obj.setSources.insert(pfrom->addr.ip);
+
+    if (!AdvertInsert(obj))
+        return;
+
+    // Relay
+    CRITICAL_BLOCK(cs_vNodes)
+        foreach(CNode* pnode, vNodes)
+            if (pnode != pfrom && (nHops < PUBLISH_HOPS || pnode->IsSubscribed(nChannel)))
+                pnode->PushMessage("publish", nChannel, nHops, obj);
+}
+
+template<typename T>
+void AdvertStopPublish(CNode* pfrom, unsigned int nChannel, unsigned int nHops, T& obj)
+{
+    uint256 hash = obj.GetHash();
+
+    CRITICAL_BLOCK(cs_vNodes)
+        foreach(CNode* pnode, vNodes)
+            if (pnode != pfrom && (nHops < PUBLISH_HOPS || pnode->IsSubscribed(nChannel)))
+                pnode->PushMessage("pub-cancel", nChannel, nHops, hash);
+
+    AdvertErase(obj);
+}
+
+template<typename T>
+void AdvertRemoveSource(CNode* pfrom, unsigned int nChannel, unsigned int nHops, T& obj)
+{
+    // Remove a source
+    obj.setSources.erase(pfrom->addr.ip);
+
+    // If no longer supported by any sources, cancel it
+    if (obj.setSources.empty())
+        AdvertStopPublish(pfrom, nChannel, nHops, obj);
+}
